<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fantasy Baseball Civil War</title>

    <!-- Favicon for browsers -->
    <link rel="icon" type="image/png" sizes="32x32" href="league_logo.png">
    <link rel="icon" type="image/png" sizes="16x16" href="league_logo.png">

    <!-- For iOS/Safari bookmarks -->
    <link rel="apple-touch-icon" sizes="180x180" href="league_logo.png">

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            color: #333;
            min-height: 100vh;
            padding-top: 120px;
            /* header (70px) + nav (~50px) */
        }

        header.desktop-header {
            background: #4a5d23;
            /* Olive/brown color to match banner edges */
            padding: 0;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 200;
        }

        /* Mobile header - hidden on desktop */
        header.mobile-header {
            display: none;
        }

        .header-container {
            position: relative;
            display: block;
        }

        .header-banner {
            width: 100%;
            height: auto;
            display: block;
            max-height: 70px;
            object-fit: cover;
        }

        .header-league-link {
            position: absolute;
            top: 0;
            left: 0;
            width: 12%;
            /* Full width of FBCW red box area */
            height: 100%;
            cursor: pointer;
            z-index: 10;
        }

        .header-league-link:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .league-logo {
            width: 50px;
            height: 50px;
            object-fit: contain;
        }

        .header-content {
            flex: 1;
        }

        h1 {
            color: #1e3c72;
            font-size: 2.2rem;
            margin-bottom: 0.3rem;
        }

        @media (max-width: 768px) {

            /* Hide desktop header on mobile */
            header.desktop-header {
                display: none;
            }

            /* Show mobile header */
            header.mobile-header {
                display: block;
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                z-index: 200;
                box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
            }

            .mobile-header-container {
                position: relative;
                width: 100%;
            }

            .mobile-header-banner {
                width: 100%;
                height: auto;
                display: block;
            }

            /* Clickable zones positioned over the banner */
            .mobile-zone {
                position: absolute;
                top: 0;
                height: 100%;
                z-index: 10;
            }

            .mobile-zone:active {
                background: rgba(255, 255, 255, 0.15);
            }

            /* Zone positions based on new banner layout */
            /* Logo area covers the left box */
            .zone-logo {
                left: 0;
                width: 35%; 
            }

            /* Icon 1: Calendar */
            .zone-seasons {
                left: 35%;
                width: 10.5%;
            }

            /* Icon 2: Ribbon */
            .zone-awards {
                left: 45.5%;
                width: 10.5%;
            }
            
            /* Icon 3: Trophy (NEW) */
            .zone-champions {
                left: 56.0%;
                width: 10.5%;
            }

            /* Icon 4: Gauge */
            .zone-scoring {
                left: 66.5%;
                width: 10.5%;
            }

            /* Icon 5: Head */
            .zone-managers {
                left: 77.0%;
                width: 10.5%;
            }

            /* Hide desktop nav on mobile */
            nav {
                display: none;
            }

            body {
                padding-top: 55px;
            }

            .header-league-link {
                width: 18%;
                /* Larger tap target on mobile */
            }

            .league-logo {
                width: 40px;
                height: 40px;
            }

            h1 {
                font-size: 1.5rem;
            }

            .section {
                padding: 1rem;
            }
        }

        .tagline {
            color: #666;
            font-style: italic;
            font-size: 0.95rem;
        }

        nav {
            background: rgba(255, 255, 255, 0.9);
            padding: 0.5rem;
            text-align: center;
            position: fixed;
            top: 70px;
            left: 0;
            right: 0;
            z-index: 100;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }

        @media (max-width: 768px) {
            body {
                padding-top: 95px;
            }

            nav {
                top: 50px;
                padding: 0.4rem;
            }
        }

        nav button {
            background: #2a5298;
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            margin: 0.25rem;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1rem;
            transition: background 0.3s;
        }

        @media (max-width: 768px) {
            nav button {
                padding: 0.6rem 1rem;
                font-size: 0.9rem;
                margin: 0.2rem;
            }
        }

        nav button:hover {
            background: #1e3c72;
        }

        nav button.active {
            background: #ff6b6b;
        }

        .container {
            max-width: 1200px;
            margin: 2rem auto;
            padding: 0 1rem;
        }

        .section {
            display: none;
            background: white;
            padding: 2rem;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            margin-bottom: 2rem;
            overflow-x: hidden;
        }

        @media (max-width: 768px) {
            .section {
                padding: 0.75rem;
                margin-bottom: 1rem;
            }

            .container {
                padding: 0 0.5rem;
                margin: 0.5rem auto;
            }
        }

        .section.active {
            display: block;
            animation: fadeIn 0.5s;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(20px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        h2 {
            color: #1e3c72;
            margin-bottom: 1.5rem;
            border-bottom: 3px solid #ff6b6b;
            padding-bottom: 0.5rem;
        }

        @media (max-width: 768px) {
            h2 {
                font-size: 1.2rem;
                margin-bottom: 0.75rem;
            }

            h3 {
                font-size: 1rem;
            }

            label {
                font-size: 0.85rem;
            }

            select {
                font-size: 0.85rem;
                padding: 0.4rem;
            }
        }

        .standings-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 1rem;
            font-size: 0.95rem;
        }

        .team-logo {
            width: 30px;
            height: 30px;
            object-fit: contain;
            vertical-align: middle;
            margin-right: 0.5rem;
            border-radius: 50%;
            background: white;
            padding: 0.15rem;
        }

        .manager-cell {
            display: flex;
            align-items: center;
        }

        .team-cell-content {
            display: flex;
            align-items: center;
        }

        .player-award-cell {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .player-award-headshot {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            object-fit: cover;
            background: #e0e0e0;
        }

        .table-wrapper {
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
            margin: 1rem 0;
        }

        @media (max-width: 768px) {
            .table-wrapper {
                overflow-x: visible;
            }
        }

        @media (max-width: 768px) {
            .standings-table {
                font-size: 0.65rem;
                width: 100%;
                table-layout: fixed;
                border-collapse: collapse;
            }

            .standings-table th,
            .standings-table td {
                padding: 0.3rem 0.2rem;
                white-space: nowrap;
                overflow: hidden;
                vertical-align: middle;
            }

            .standings-table tr {
                border-bottom: 1px solid #ddd;
            }

            .standings-table td {
                border-bottom: none; /* Remove individual cell borders, use row border instead */
            }

            /* Column widths for mobile */
            .standings-table th:nth-child(1),
            .standings-table td:nth-child(1) {
                width: 8%;
            }

            /* Rank */

            .standings-table th:nth-child(2),
            .standings-table td:nth-child(2) {
                width: 18%;
            }

            /* Manager */

            .standings-table th:nth-child(3),
            .standings-table td:nth-child(3) {
                width: 28%;
            }

            /* Team Name */

            .standings-table th:nth-child(3) {
                width: 32%;
            }
            
            .standings-table td:nth-child(3) {
                width: 32%;
                white-space: normal;    /* Allows text to wrap */
                line-height: 1.1;       /* Tight line height */
                overflow: visible;
                padding-right: 2px;
            }

            .standings-table td:nth-child(3) .team-cell-content {
                display: flex;          /* Enables side-by-side layout */
                align-items: center;    /* Vertically centers logo and text */
            }

            /* Wins */

            .standings-table th:nth-child(5),
            .standings-table td:nth-child(5) {
                width: 9%;
            }

            /* Losses */

            .standings-table th:nth-child(6),
            .standings-table td:nth-child(6) {
                width: 9%;
            }

            /* Win % */

            .standings-table th:nth-child(7),
            .standings-table td:nth-child(7) {
                width: 14%;
            }

            /* Total Points */

            .standings-table .team-logo {
                width: 24px;      /* Increased from 16px */
                height: 24px;     /* Increased from 16px */
                min-width: 24px;  /* Prevents squishing */
                margin-right: 4px;
                object-fit: contain;
            }
        }

        .standings-table th {
            background: #2a5298;
            color: white;
            padding: 1rem;
            text-align: left;
        }

        .standings-table td {
            padding: 0.75rem 1rem;
            border-bottom: 1px solid #ddd;
        }

        .standings-table tr:hover {
            background: #f5f5f5;
        }

        .season-selector {
            margin-bottom: 1.5rem;
        }

        .season-selector label {
            font-weight: bold;
            margin-right: 1rem;
            color: #1e3c72;
        }

        .season-selector select {
            padding: 0.5rem;
            font-size: 1rem;
            border: 2px solid #2a5298;
            border-radius: 5px;
        }

        .manager-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 1.5rem;
            margin-top: 1.5rem;
        }

        @media (max-width: 768px) {
            .manager-grid {
                grid-template-columns: 1fr;
                gap: 1rem;
            }
        }

        .manager-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 1.5rem;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
            transition: transform 0.3s;
            cursor: pointer;
        }

        .manager-card:hover {
            transform: translateY(-5px);
        }

        .manager-card.inactive {
            background: linear-gradient(135deg, #757575 0%, #616161 100%);
            opacity: 0.8;
        }

        .manager-card h3 {
            margin-bottom: 1rem;
            font-size: 1.5rem;
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .manager-card .manager-logo {
            width: 40px;
            height: 40px;
            object-fit: contain;
            background: white;
            border-radius: 50%;
            padding: 0.25rem;
        }

        .manager-card .stat {
            margin: 0.5rem 0;
            font-size: 0.95rem;
        }

        .manager-card .stat strong {
            display: inline-block;
            width: 140px;
        }

        .manager-card .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.3);
            padding: 0.25rem 0.5rem;
            border-radius: 3px;
            font-size: 0.85rem;
        }

        .manager-card .awards-row {
            display: flex;
            align-items: center;
            gap: 0.4rem;
            flex-wrap: wrap;
        }

        .manager-card .award-badge {
            position: relative;
            font-size: 1.6rem;
            line-height: 1;
            display: inline-block;
        }

        .manager-card .award-count {
            position: absolute;
            bottom: -2px;
            right: -4px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            font-size: 0.55rem;
            padding: 0.1rem 0.2rem;
            border-radius: 2px;
            font-weight: bold;
            line-height: 1;
            min-width: 14px;
            text-align: center;
        }

        /* Global award badge styles (for modal and other uses) */
        .awards-row {
            display: flex;
            align-items: center;
            gap: 0.4rem;
            flex-wrap: wrap;
        }

        .award-badge {
            position: relative;
            font-size: 1.6rem;
            line-height: 1;
            display: inline-block;
        }

        .award-image {
            width: 28px;
            height: 28px;
            object-fit: contain;
            vertical-align: middle;
        }

        .award-count {
            position: absolute;
            bottom: -2px;
            right: -4px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            font-size: 0.55rem;
            padding: 0.1rem 0.2rem;
            border-radius: 2px;
            font-weight: bold;
            line-height: 1;
            min-width: 14px;
            text-align: center;
        }

        /* Manager Detail Modal */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            animation: fadeIn 0.3s;
            align-items: center;
            justify-content: center;
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background: white;
            padding: 0;
            border-radius: 15px;
            max-width: 900px;
            width: 90%;
            max-height: 85vh;
            overflow: hidden;
            position: relative;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
            display: flex;
            flex-direction: column;
        }

        .modal-header {
            position: sticky;
            top: 0;
            background: white;
            z-index: 10;
            padding: 2rem;
            padding-bottom: 1rem;
            border-bottom: 3px solid #2a5298;
            border-radius: 15px 15px 0 0;
        }

        .modal-body-scroll {
            overflow-y: auto;
            padding: 2rem;
            flex: 1;
        }

        @media (max-width: 768px) {
            .modal-content {
                width: 95%;
                max-height: 90vh;
            }

            .modal-header {
                padding: 1.5rem;
                padding-bottom: 1rem;
            }

            .modal-body-scroll {
                padding: 1.5rem;
            }
        }

        .modal-close {
            position: absolute;
            right: 1.5rem;
            top: 1.5rem;
            font-size: 2rem;
            cursor: pointer;
            color: #666;
            transition: color 0.3s;
            z-index: 11;
        }

        .modal-close:hover {
            color: #000;
        }

        .modal-header {
            position: sticky;
            top: 0;
            background: white;
            z-index: 10;
            padding: 2rem;
            padding-bottom: 1rem;
            border-bottom: 3px solid #2a5298;
            border-radius: 15px 15px 0 0;
        }

        .modal-header h2 {
            color: #1e3c72;
            margin-bottom: 0.5rem;
            border: none;
            padding: 0;
        }

        .modal-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
            margin-bottom: 2rem;
        }

        @media (max-width: 768px) {
            .modal-stats {
                grid-template-columns: repeat(2, 1fr);
                gap: 0.75rem;
            }

            .stat-box {
                padding: 0.75rem;
            }

            .stat-box .value {
                font-size: 1.4rem;
            }

            .stat-box .label {
                font-size: 0.8rem;
            }
        }

        .stat-box {
            background: #f8f9fa;
            padding: 1rem;
            border-radius: 8px;
            text-align: center;
        }

        .stat-box .value {
            font-size: 1.8rem;
            font-weight: bold;
            color: #2a5298;
        }

        .stat-box .label {
            font-size: 0.9rem;
            color: #666;
            margin-top: 0.5rem;
        }

        .timeline {
            margin: 2rem 0;
        }

        .timeline h3 {
            color: #1e3c72;
            margin-bottom: 1rem;
        }

        .timeline-item {
            display: flex;
            padding: 1rem;
            border-left: 3px solid #2a5298;
            margin-bottom: 1rem;
            background: #f8f9fa;
            border-radius: 0 8px 8px 0;
            align-items: center;
        }

        .timeline-item .year {
            font-weight: bold;
            color: #2a5298;
            min-width: 60px;
            font-size: 1.1rem;
        }

        .timeline-item .details {
            flex: 1;
            margin-left: 1rem;
        }

        .timeline-item .timeline-logo {
            width: 35px;
            height: 35px;
            object-fit: contain;
            border-radius: 50%;
            background: white;
            padding: 0.25rem;
            margin-left: 1rem;
        }

        .timeline-item .rank {
            display: inline-block;
            background: #2a5298;
            color: white;
            padding: 0.25rem 0.75rem;
            border-radius: 20px;
            margin-right: 1rem;
            font-size: 0.9rem;
        }

        .timeline-item .rank.champion {
            background: #ffd700;
            color: #000;
        }

        .timeline-item .rank.runner-up {
            background: #c0c0c0;
            color: #000;
        }

        .matchup-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 1rem;
            overflow-x: auto;
            display: block;
        }

        .matchup-table thead,
        .matchup-table tbody,
        .matchup-table tr {
            display: table;
            width: 100%;
            table-layout: fixed;
        }

        @media (max-width: 768px) {
            .matchup-table {
                font-size: 0.8rem;
            }

            .matchup-table th,
            .matchup-table td {
                padding: 0.5rem 0.25rem;
            }
        }

        .matchup-table th {
            background: #2a5298;
            color: white;
            padding: 0.75rem;
            text-align: left;
            cursor: pointer;
            user-select: none;
            position: relative;
        }

        .matchup-table th:hover {
            background: #1e3c72;
        }

        .matchup-table th.sortable::after {
            content: ' ⇅';
            opacity: 0.5;
            font-size: 0.8rem;
        }

        .matchup-table th.sorted-asc::after {
            content: ' ▲';
            opacity: 1;
        }

        .matchup-table th.sorted-desc::after {
            content: ' ▼';
            opacity: 1;
        }

        .matchup-table td {
            padding: 0.75rem;
            border-bottom: 1px solid #ddd;
        }

        .matchup-table tr:hover {
            background: #f8f9fa;
        }

        .awards-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 1.5rem;
        }

        @media (max-width: 900px) {
            .awards-grid {
                grid-template-columns: 1fr;
            }
        }

        .award-section {
            margin-bottom: 1rem;
        }

        .award-section h3 {
            color: #1e3c72;
            margin-bottom: 1rem;
            font-size: 1.3rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .award-icon {
            font-size: 1.5rem;
        }

        .award-header-image {
            width: 28px;
            height: 28px;
            object-fit: contain;
            vertical-align: middle;
        }

        .award-table-wrapper {
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
            margin-bottom: 1rem;
        }

        .award-table {
            width: 100%;
            border-collapse: collapse;
        }

        .award-table th {
            background: #2a5298;
            color: white;
            padding: 0.75rem;
            text-align: left;
            white-space: nowrap;
        }

        .award-table td {
            padding: 0.75rem;
            border-bottom: 1px solid #ddd;
        }

        .award-table tr:hover {
            background: #f8f9fa;
        }

        .award-value {
            font-weight: bold;
            color: #2a5298;
        }

        /* ===== PLAYER SCORING STYLES ===== */
        .player-controls {
            margin-bottom: 1.5rem;
        }

        .player-control-row {
            display: flex;
            flex-wrap: wrap;
            gap: 1rem;
            margin-bottom: 1rem;
            align-items: flex-end;
        }

        .player-control-row .season-selector,
        .player-control-row .position-filter,
        .player-control-row .manager-filter {
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
        }

        .player-control-row label {
            font-weight: bold;
            color: #1e3c72;
            font-size: 0.85rem;
        }

        .player-control-row select {
            padding: 0.5rem;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 0.9rem;
            min-width: 150px;
        }

        .player-search {
            width: 100%;
            max-width: 400px;
        }

        .player-search input {
            width: 100%;
            padding: 0.6rem 1rem;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 1rem;
        }

        .player-search input:focus {
            outline: none;
            border-color: #2a5298;
            box-shadow: 0 0 0 2px rgba(42, 82, 152, 0.1);
        }

        .player-summary {
            margin-bottom: 1rem;
            color: #666;
            font-size: 0.9rem;
        }

        .player-table-wrapper {
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
        }

        .player-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.9rem;
        }

        .player-table th {
            background: linear-gradient(135deg, #1e3c72, #2a5298);
            color: white;
            padding: 0.75rem 0.5rem;
            text-align: left;
            white-space: nowrap;
            position: sticky;
            top: 0;
        }

        .player-table th.sortable {
            cursor: pointer;
            user-select: none;
        }

        .player-table th.sortable:hover {
            background: linear-gradient(135deg, #2a5298, #3a6cc8);
        }

        .player-table th.sort-asc::after {
            content: ' ▲';
            font-size: 0.7rem;
        }

        .player-table th.sort-desc::after {
            content: ' ▼';
            font-size: 0.7rem;
        }

        .player-table td {
            padding: 0.6rem 0.5rem;
            border-bottom: 1px solid #eee;
            vertical-align: middle;
        }

        .player-table tr:hover {
            background: #f0f4f8;
        }

        .player-table .stat-col {
            text-align: center;
        }

        .player-name-cell {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            cursor: pointer;
        }

        .player-name-cell:hover .player-name {
            color: #2a5298;
            text-decoration: underline;
        }

        .player-headshot {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            object-fit: cover;
            background: #f0f0f0;
        }

        .player-name {
            font-weight: 500;
        }

        .player-mlb-team {
            font-size: 0.75rem;
            color: #888;
        }

        .player-team-cell {
            display: flex;
            align-items: center;
            gap: 0.4rem;
        }

        .player-team-logo {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            object-fit: cover;
            background: white;
        }

        .player-fantasy-team {
            font-size: 0.8rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 120px;
        }

        .player-position {
            font-weight: 500;
            color: #555;
        }

        .player-points {
            font-weight: bold;
            color: #1e3c72;
        }

        /* Hide batter/pitcher stats based on filter */
        .show-batters .pitcher-stat,
        .show-pitchers .batter-stat {
            display: none;
        }

        /* Player Modal Styles */
        .player-modal-content {
            max-width: 420px;
            background: transparent;
            box-shadow: none;
            border-radius: 12px;
            overflow: visible;
        }

        /* Baseball Card Design */
        .baseball-card {
            background: linear-gradient(135deg, #f5d742 0%, #e8c92e 50%, #d4b82a 100%);
            border-radius: 12px;
            border: 4px solid #1e3c72;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3), inset 0 1px 0 rgba(255, 255, 255, 0.3);
            overflow: hidden;
            position: relative;
        }

        .card-header {
            background: linear-gradient(180deg, #1e3c72 0%, #2a5298 100%);
            padding: 0.75rem 1rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 3px solid #f5d742;
        }

        .card-player-name {
            color: white;
            font-size: 1.4rem;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 1px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
            flex: 1;
            text-align: center;
        }

        .card-mlb-logo {
            width: 40px;
            height: 40px;
            object-fit: contain;
        }

        .card-mlb-team {
            color: #f5d742;
            font-size: 0.9rem;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .card-photo-section {
            position: relative;
            background: linear-gradient(180deg, #87CEEB 0%, #4a90c2 60%, #2d6a9f 100%);
            padding: 1rem;
            display: flex;
            justify-content: center;
            align-items: flex-end;
            min-height: 200px;
        }

        .card-photo-frame {
            position: relative;
            width: 150px;
            height: 150px;
            border-radius: 50%;
            background: white;
            padding: 5px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            border: 3px solid #f5d742;
        }

        .card-headshot {
            width: 100%;
            height: 100%;
            border-radius: 50%;
            object-fit: cover;
            background: #e0e0e0;
        }

        .card-position-badge {
            position: absolute;
            bottom: 5px;
            right: 5px;
            background: #1e3c72;
            color: #f5d742;
            font-weight: bold;
            font-size: 0.85rem;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            border: 2px solid #f5d742;
        }

        .card-team-logo-corner {
            position: absolute;
            bottom: 10px;
            left: 10px;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            object-fit: contain;
            background: white;
            padding: 4px;
            border: 2px solid #f5d742;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }

        .card-stats-corner {
            position: absolute;
            top: 10px;
            right: 10px;
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 4px;
        }

        .card-team-badge {
            background: rgba(255, 255, 255, 0.95);
            padding: 0.3rem 0.6rem;
            border-radius: 4px;
            font-size: 0.75rem;
            font-weight: bold;
            color: #1e3c72;
            border: 2px solid #1e3c72;
        }

        .card-fantasy-points {
            background: #f5d742;
            color: #1e3c72;
            font-size: 1.1rem;
            font-weight: bold;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            border: 2px solid #1e3c72;
            text-align: center;
        }

        .card-fantasy-points .pts-label {
            font-size: 0.6rem;
            font-weight: normal;
            display: block;
        }

        .card-position-rank {
            background: #1e3c72;
            color: #f5d742;
            font-size: 0.75rem;
            font-weight: bold;
            padding: 0.2rem 0.5rem;
            border-radius: 4px;
            border: 2px solid #f5d742;
        }

        .card-info-strip {
            background: #1e3c72;
            color: white;
            padding: 0.5rem 1rem;
            display: flex;
            justify-content: space-between;
            font-size: 0.8rem;
            border-top: 2px solid #f5d742;
            border-bottom: 2px solid #f5d742;
        }

        .card-info-strip span {
            display: flex;
            align-items: center;
            gap: 0.25rem;
        }

        .card-stats-section {
            background: #fffef5;
            padding: 0.75rem;
        }

        .card-stats-title {
            background: #1e3c72;
            color: #f5d742;
            font-size: 0.75rem;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 1px;
            padding: 0.3rem 0.5rem;
            margin: -0.75rem -0.75rem 0.5rem -0.75rem;
            text-align: center;
        }

        .card-stats-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.75rem;
        }

        .card-stats-table th {
            background: #2a5298;
            color: white;
            padding: 0.35rem 0.25rem;
            text-align: center;
            font-weight: bold;
            font-size: 0.65rem;
            text-transform: uppercase;
            border: 1px solid #1e3c72;
        }

        .card-stats-table td {
            background: white;
            padding: 0.35rem 0.25rem;
            text-align: center;
            border: 1px solid #ddd;
            font-weight: 600;
            color: #333;
        }

        .card-stats-table tr:nth-child(even) td {
            background: #f8f8f0;
        }

        .card-history-section {
            background: #fffef5;
            padding: 0.5rem 0.75rem 0.75rem;
            border-top: 2px dashed #ccc;
        }

        .card-history-title {
            font-size: 0.7rem;
            font-weight: bold;
            color: #1e3c72;
            text-transform: uppercase;
            margin-bottom: 0.4rem;
            text-align: center;
        }

        .card-history-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.65rem;
        }

        .card-history-table th {
            background: #1e3c72;
            color: white;
            padding: 0.25rem;
            text-align: center;
            font-size: 0.6rem;
        }

        .card-history-table td {
            padding: 0.25rem;
            text-align: center;
            border-bottom: 1px solid #eee;
        }

        .card-history-table .team-logo-small {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            vertical-align: middle;
            margin-right: 3px;
        }

        .card-footer {
            background: linear-gradient(180deg, #1e3c72 0%, #152a52 100%);
            color: #f5d742;
            padding: 0.5rem 1rem;
            font-size: 0.65rem;
            text-align: center;
            border-top: 3px solid #f5d742;
        }

        .card-footer .owner-info {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 0.5rem;
        }

        .card-footer .owner-logo {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border: 1px solid #f5d742;
        }

        /* Scrollable stats area */
        .card-scrollable {
            max-height: 280px;
            overflow-y: auto;
            scrollbar-width: thin;
            scrollbar-color: #1e3c72 #f5d742;
        }

        .card-scrollable::-webkit-scrollbar {
            width: 6px;
        }

        .card-scrollable::-webkit-scrollbar-track {
            background: #f5d742;
        }

        .card-scrollable::-webkit-scrollbar-thumb {
            background: #1e3c72;
            border-radius: 3px;
        }

        /* Hide the default modal body scroll for player modal */
        #player-modal .modal-body-scroll {
            padding: 0;
            max-height: none;
            overflow: visible;
        }

        #player-modal .modal-close {
            color: white;
            background: #1e3c72;
            border: 2px solid #f5d742;
            border-radius: 50%;
            width: 28px;
            height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10;
            top: 8px;
            right: 8px;
        }

        #player-modal .modal-close:hover {
            background: #f5d742;
            color: #1e3c72;
        }

        #player-modal-header {
            display: none; /* Hide default header, we'll build card structure in body */
        }

        /* Mobile styles for baseball card */
        @media (max-width: 480px) {
            .player-modal-content {
                max-width: 95vw;
                margin: 0.5rem;
            }

            .baseball-card {
                border-width: 3px;
            }

            .card-header {
                padding: 0.5rem 0.75rem;
            }

            .card-mlb-logo {
                width: 30px;
                height: 30px;
            }

            .card-player-name {
                font-size: 1.1rem;
            }

            .card-fantasy-points {
                font-size: 0.9rem;
                padding: 0.15rem 0.35rem;
            }

            .card-fantasy-points .pts-label {
                font-size: 0.5rem;
            }

            .card-photo-section {
                min-height: 160px;
                padding: 0.75rem;
            }

            .card-photo-frame {
                width: 120px;
                height: 120px;
            }

            .card-position-badge {
                font-size: 0.75rem;
            }

            .card-team-badge {
                font-size: 0.65rem;
                padding: 0.2rem 0.4rem;
            }

            .card-team-logo-corner {
                width: 40px;
                height: 40px;
            }

            .card-position-rank {
                font-size: 0.65rem;
                padding: 0.15rem 0.35rem;
            }

            .card-mlb-team {
                font-size: 0.7rem;
            }

            .card-info-strip {
                font-size: 0.7rem;
                padding: 0.4rem 0.75rem;
            }

            .card-stats-table th,
            .card-stats-table td {
                padding: 0.25rem 0.15rem;
                font-size: 0.6rem;
            }

            .card-history-table {
                font-size: 0.6rem;
            }

            .card-scrollable {
                max-height: 220px;
            }
        }

        .player-history-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.9rem;
        }

        .player-history-table th {
            background: #f0f4f8;
            padding: 0.6rem;
            text-align: left;
            font-weight: 600;
            color: #1e3c72;
        }

        .player-history-table td {
            padding: 0.6rem;
            border-bottom: 1px solid #eee;
        }

        .player-history-table tr:hover {
            background: #f8f9fa;
        }

        /* Hall of Champions Styles */
        .champion-header {
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 50%, #1e3c72 100%);
            color: white;
            padding: 2rem;
            border-radius: 12px;
            margin-bottom: 1.5rem;
            display: flex;
            align-items: center;
            gap: 1.5rem;
            box-shadow: 0 4px 15px rgba(30, 60, 114, 0.3);
        }

        .champion-header .team-logo {
            width: 100px;
            height: 100px;
            border-radius: 50%;
            object-fit: cover;
            border: 4px solid rgba(255, 215, 0, 0.8);
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.4);
        }

        .champion-header .champion-info h3 {
            font-size: 1.8rem;
            margin: 0 0 0.25rem 0;
            color: #ffd700;
        }

        .champion-header .champion-info .manager-name {
            font-size: 1.2rem;
            opacity: 0.9;
        }

        .champion-header .champion-info .season-year {
            font-size: 1rem;
            opacity: 0.7;
            margin-top: 0.5rem;
        }

        .champion-header .trophy-icon {
            font-size: 3rem;
            margin-left: auto;
        }

        .championship-count-banner {
            background: linear-gradient(90deg, #ffd700, #ffec8b, #ffd700);
            color: #1e3c72;
            text-align: center;
            padding: 1rem;
            border-radius: 8px;
            margin-bottom: 1.5rem;
            font-size: 1.3rem;
            font-weight: bold;
            box-shadow: 0 2px 8px rgba(255, 215, 0, 0.3);
        }

        .champion-stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 1rem;
            margin-bottom: 2rem;
        }

        .champion-stat-card {
            background: white;
            border-radius: 10px;
            padding: 1.25rem;
            text-align: center;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            border: 1px solid #e0e0e0;
        }

        .champion-stat-card .stat-value {
            font-size: 1.8rem;
            font-weight: bold;
            color: #1e3c72;
        }

        .champion-stat-card .stat-label {
            font-size: 0.85rem;
            color: #666;
            margin-top: 0.25rem;
        }

        .champion-section {
            background: white;
            border-radius: 10px;
            padding: 1.5rem;
            margin-bottom: 1.5rem;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .champion-section h3 {
            color: #1e3c72;
            margin: 0 0 1rem 0;
            padding-bottom: 0.75rem;
            border-bottom: 2px solid #eee;
        }

        .champion-schedule-table {
            width: 100%;
            border-collapse: collapse;
        }

        .champion-schedule-table th {
            background: #f0f4f8;
            padding: 0.75rem;
            text-align: left;
            font-weight: 600;
            color: #1e3c72;
        }

        .champion-schedule-table td {
            padding: 0.75rem;
            border-bottom: 1px solid #eee;
        }

        .champion-schedule-table .result-win {
            color: #28a745;
            font-weight: bold;
        }

        .champion-schedule-table .result-loss {
            color: #dc3545;
            font-weight: bold;
        }

        .champion-schedule-table .schedule-row-win {
            background: rgba(40, 167, 69, 0.08);
        }

        .champion-schedule-table .schedule-row-win:hover {
            background: rgba(40, 167, 69, 0.15);
        }

        .champion-schedule-table .schedule-row-loss {
            background: rgba(220, 53, 69, 0.08);
        }

        .champion-schedule-table .schedule-row-loss:hover {
            background: rgba(220, 53, 69, 0.15);
        }

        .champion-schedule-table .playoff-week {
            border-left: 3px solid #ffd700;
        }

        .champion-schedule-table .championship-week {
            border-left: 3px solid #ffd700;
            background: rgba(255, 215, 0, 0.15) !important;
        }

        .champion-schedule-table .championship-week:hover {
            background: rgba(255, 215, 0, 0.25) !important;
        }

        .schedule-opponent {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .schedule-team-logo {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            object-fit: cover;
        }

        .roster-grid {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .roster-player-card {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            background: #f8f9fa;
            border-radius: 8px;
            padding: 0.75rem;
            border: 1px solid #e0e0e0;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .roster-player-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }

        .roster-player-card .player-headshot {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            object-fit: cover;
        }

        .roster-player-card .player-info {
            flex: 1;
        }

        .roster-player-card .player-name {
            font-weight: 600;
            color: #1e3c72;
        }

        .roster-player-card .player-position {
            font-size: 0.8rem;
            color: #666;
        }

        .roster-player-card .player-points {
            text-align: right;
        }

        .roster-player-card .points-value {
            font-size: 1.2rem;
            font-weight: bold;
            color: #1e3c72;
        }

        .roster-player-card .points-label {
            font-size: 0.7rem;
            color: #888;
        }

        .roster-columns {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 2rem;
        }

        @media (max-width: 900px) {
            .roster-columns {
                grid-template-columns: 1fr;
            }
        }

        .roster-column {
            min-width: 0;
        }

        .roster-section-title {
            font-size: 1.1rem;
            font-weight: 600;
            color: #1e3c72;
            margin: 0 0 0.75rem 0;
            padding-bottom: 0.5rem;
            border-bottom: 2px solid #1e3c72;
        }

        .prospects-section {
            margin-top: 1.5rem;
            padding-top: 1rem;
            border-top: 2px dashed #ddd;
        }

        .prospects-section .roster-section-title {
            color: #888;
            border-bottom-color: #ccc;
        }

        .prospects-section .roster-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 0.5rem;
        }

        .roster-player-card.prospect {
            background: #f0f0f0;
            opacity: 0.8;
        }

        .roster-player-card.prospect .points-value {
            color: #999;
        }

        /* Mobile styles for Player Scoring */
        @media (max-width: 768px) {
            .player-control-row {
                flex-direction: column;
                gap: 0.75rem;
            }

            .player-control-row .season-selector,
            .player-control-row .position-filter,
            .player-control-row .manager-filter {
                width: 100%;
            }

            .player-control-row select {
                width: 100%;
                min-width: unset;
            }

            .player-search {
                max-width: 100%;
            }

            .player-table-wrapper {
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
            }

            .player-table {
                font-size: 0.7rem;
                min-width: 600px;
            }

            .player-table th,
            .player-table td {
                padding: 0.4rem 0.3rem;
            }

            .player-headshot {
                width: 24px;
                height: 24px;
            }

            .player-team-logo {
                width: 18px;
                height: 18px;
            }

            .player-name-cell {
                gap: 0.3rem;
            }

            .player-mlb-team {
                font-size: 0.65rem;
            }

            .player-fantasy-team {
                max-width: 60px;
                font-size: 0.7rem;
            }

            /* Player Modal Mobile */
            .player-modal-content {
                width: 95%;
                max-height: 90vh;
            }

            #player-modal-header {
                flex-direction: column;
                text-align: center;
                padding: 1rem;
                gap: 0.75rem;
            }

            .player-modal-headshot {
                width: 60px;
                height: 60px;
            }

            .player-modal-info h2 {
                font-size: 1.2rem;
            }

            .player-modal-info .player-details {
                flex-wrap: wrap;
                justify-content: center;
                gap: 0.5rem;
            }

            .player-modal-points {
                margin-left: 0;
                text-align: center;
            }

            .player-modal-points .points-value {
                font-size: 1.5rem;
            }

            .player-stats-grid {
                grid-template-columns: repeat(4, 1fr);
                gap: 0.5rem;
            }

            .player-stat-box {
                padding: 0.5rem;
            }

            .player-stat-box .stat-value {
                font-size: 1rem;
            }

            .player-stat-box .stat-label {
                font-size: 0.65rem;
            }

            .player-history-table {
                font-size: 0.8rem;
            }

            .player-history-table th,
            .player-history-table td {
                padding: 0.4rem;
            }
        }

        .loading {
            text-align: center;
            padding: 2rem;
            color: #666;
        }

        @media (max-width: 768px) {
            .award-table {
                font-size: 0.6rem;
                width: 100%;
                table-layout: fixed;
            }

            .award-table th,
            .award-table td {
                padding: 0.3rem 0.2rem;
                overflow: hidden;
                text-overflow: ellipsis;
                white-space: nowrap;
            }

            /* Award table column widths */
            .award-table th:nth-child(1),
            .award-table td:nth-child(1) {
                width: 15%;
            }

            /* Year */

            .award-table th:nth-child(2),
            .award-table td:nth-child(2) {
                width: 25%;
            }

            /* Manager */

            .award-table th:nth-child(3),
            .award-table td:nth-child(3) {
                width: 40%;
            }

            /* Team Name */

            .award-table th:nth-child(4),
            .award-table td:nth-child(4) {
                width: 20%;
            }

            /* Points/Wins */

            .award-section h3 {
                font-size: 1rem;
            }

            .award-icon {
                font-size: 1rem;
            }

            .awards-grid {
                grid-template-columns: 1fr;
                gap: 1rem;
            }

            .award-table-wrapper {
                overflow-x: visible;
            }
        }

        .error {
            background: #fee;
            border: 1px solid #fcc;
            padding: 1rem;
            border-radius: 5px;
            color: #c33;
            margin: 1rem 0;
        }

        /* Season Chart Styles */
        .chart-svg {
            overflow: visible;
        }

        .chart-line {
            fill: none;
            stroke-width: 2.5;
            transition: opacity 0.3s ease, stroke-width 0.3s ease;
        }

        .chart-line.faded {
            opacity: 0.15;
        }

        .chart-line.highlighted {
            stroke-width: 4;
        }

        .team-logo-marker {
            cursor: pointer;
            transition: opacity 0.3s ease, transform 0.3s ease;
        }

        .team-logo-marker.faded {
            opacity: 0.2;
        }

        .team-logo-marker.highlighted {
            transform-origin: center;
        }

        .chart-tooltip {
            position: absolute;
            background: rgba(30, 60, 114, 0.95);
            color: white;
            padding: 0.5rem 0.75rem;
            border-radius: 6px;
            font-size: 0.85rem;
            pointer-events: none;
            z-index: 100;
            white-space: nowrap;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
            transform: translate(-50%, -100%);
            margin-top: -10px;
        }

        .chart-tooltip::after {
            content: '';
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            border: 6px solid transparent;
            border-top-color: rgba(30, 60, 114, 0.95);
        }

        .chart-axis-label {
            font-size: 0.75rem;
            fill: #666;
        }

        .chart-grid-line {
            stroke: #e0e0e0;
            stroke-width: 1;
        }

        .chart-toggle-btn {
            background: #e0e0e0;
            color: #333;
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: background 0.3s, color 0.3s;
        }

        .chart-toggle-btn:hover {
            background: #ccc;
        }

        .chart-toggle-btn.active {
            background: #2a5298;
            color: white;
        }

        /* Win Percentage Chart Styles */
        .winpct-chart {
            font-family: inherit;
        }

        .winpct-chart .chart-line {
            transition: opacity 0.2s;
        }

        .winpct-chart .chart-line.faded {
            opacity: 0.15;
        }

        .winpct-chart .chart-line.highlighted path:first-child {
            stroke-width: 4;
        }

        #winpct-chart {
            position: relative;
        }

        #winpct-chart .chart-tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.85);
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 12px;
            pointer-events: none;
            z-index: 100;
            white-space: nowrap;
        }

        /* Mobile optimizations for chart */
        @media (max-width: 768px) {
            #season-chart-container>div:first-child {
                flex-direction: column;
                align-items: flex-start;
            }

            #season-chart {
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
            }

            .chart-toggle-btn {
                padding: 0.4rem 0.8rem;
                font-size: 0.85rem;
            }

            /* Mobile adjustments for Champion Schedule Table */
            .champion-schedule-table {
                font-size: 0.7rem; /* Reduce font size significantly */
                table-layout: fixed; /* Enforce column widths */
                width: 100%;
            }

            .champion-schedule-table th,
            .champion-schedule-table td {
                padding: 0.4rem 0.2rem; /* Tighten padding */
                white-space: nowrap; /* Prevent wrapping */
                overflow: hidden;
                text-overflow: ellipsis; /* Add ... if text is too long */
            }

            /* Week Column */
            .champion-schedule-table th:nth-child(1),
            .champion-schedule-table td:nth-child(1) {
                width: 15%;
            }

            /* Opponent Column (Give this the most space) */
            .champion-schedule-table th:nth-child(2),
            .champion-schedule-table td:nth-child(2) {
                width: 40%;
                white-space: normal; /* Allow wrapping */
                line-height: 1.2;    /* Tighter spacing */
                text-overflow: clip; /* Remove the "..." */
                overflow: visible;   /* Show content */
            }

            /* Score Column */
            .champion-schedule-table th:nth-child(3),
            .champion-schedule-table td:nth-child(3) {
                width: 33%;
                text-align: center;
                font-size: 0.65rem; /* Make score slightly smaller to fit decimals */
            }

            /* Result Column */
            .champion-schedule-table th:nth-child(4),
            .champion-schedule-table td:nth-child(4) {
                width: 10%;
                text-align: center;
            }

            /* Adjust opponent logo and text gap */
            .schedule-opponent {
                gap: 0.25rem;
            }

            .schedule-team-logo {
                width: 16px; /* Smaller logo */
                height: 16px;
            }

            .week-text {
                display: none;
            }
        }

        footer {
            background: rgba(255, 255, 255, 0.9);
            text-align: center;
            padding: 1rem;
            margin-top: 2rem;
            color: #666;
        }
    </style>
</head>

<body>
    <header class="desktop-header">
        <div class="header-container">
            <picture>
                <source srcset="header_long.png" media="(min-width: 1200px)">
                <img src="header_short.png" alt="Fantasy Baseball Civil War - Established 2017 - 12 Team Points League"
                    class="header-banner">
            </picture>
            <a href="https://baseball.fantasysports.yahoo.com/league/fantasybaseballcivilwar/2025" target="_blank"
                class="header-league-link" title="Go to Yahoo Fantasy League"></a>
        </div>
    </header>

    <header class="mobile-header">
        <div class="mobile-header-container">
            <img src="mobile_header.png" alt="Fantasy Baseball Civil War" class="mobile-header-banner">
            <a href="https://baseball.fantasysports.yahoo.com/league/fantasybaseballcivilwar/2025" target="_blank"
                class="mobile-zone zone-logo" title="Go to Yahoo Fantasy League"></a>
            
            <a href="#" class="mobile-zone zone-seasons" onclick="showSection('standings'); return false;"
                title="Seasons"></a>
            
            <a href="#" class="mobile-zone zone-awards" onclick="showSection('awards'); return false;"
                title="Awards"></a>

            <a href="#" class="mobile-zone zone-champions" onclick="showSection('champions'); return false;"
                title="Hall of Champions"></a>

            <a href="#" class="mobile-zone zone-scoring" onclick="showSection('scoring'); return false;"
                title="Player Scoring"></a>
            
            <a href="#" class="mobile-zone zone-managers" onclick="showSection('managers'); return false;"
                title="Manager Profiles"></a>
        </div>
    </header>

    <nav>
        <button onclick="showSection('standings')" class="nav-btn active">Seasons</button>
        <button onclick="showSection('awards')" class="nav-btn">Awards</button>
        <button onclick="showSection('champions')" class="nav-btn">Hall of Champions</button>
        <button onclick="showSection('scoring')" class="nav-btn">Player Scoring</button>
        <button onclick="showSection('managers')" class="nav-btn">Manager Profiles</button>
    </nav>

    <div class="container">
        <!-- Seasons Section -->
        <div id="standings" class="section active">
            <h2>Seasons</h2>

            <div class="season-selector">
                <label for="standings-season">Select Season:</label>
                <select id="standings-season" onchange="loadStandingsBySeason()">
                    <!-- Will be populated dynamically -->
                </select>
            </div>

            <div id="standings-loading" class="loading">Loading standings...</div>
            <div id="standings-error" class="error" style="display: none;"></div>

            <div class="table-wrapper">
                <table class="standings-table" id="standings-table" style="display: none;">
                    <thead>
                        <tr>
                            <th>Rank</th>
                            <th>Manager</th>
                            <th>Team Name</th>
                            <th>Wins</th>
                            <th>Losses</th>
                            <th>Win %</th>
                            <th>Total Points</th>
                        </tr>
                    </thead>
                    <tbody id="standings-body">
                    </tbody>
                </table>
            </div>

            <!-- Season Points Chart -->
            <div id="season-chart-container" style="display: none; margin-top: 2rem;">
                <div
                    style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 1rem; flex-wrap: wrap; gap: 1rem;">
                    <h3 style="color: #1e3c72; margin: 0;">Summary</h3>
                    <div style="display: flex; align-items: center; gap: 0.5rem;">
                        <label style="font-weight: bold; color: #1e3c72;">Scoring Type:</label>
                        <button id="btn-weekly" class="chart-toggle-btn active"
                            onclick="setChartType('weekly')">Weekly</button>
                        <button id="btn-total" class="chart-toggle-btn" onclick="setChartType('total')">Total</button>
                    </div>
                </div>
                <div id="season-chart"
                    style="position: relative; width: 100%; min-height: 500px; background: #fafafa; border-radius: 8px; overflow: visible;">
                </div>
            </div>
        </div>

        <!-- Awards Section -->
        <div id="awards" class="section">
            <h2>🏆 League Awards</h2>

            <div id="awards-loading" class="loading">Loading awards...</div>
            <div id="awards-error" class="error" style="display: none;"></div>

            <div id="awards-content" style="display: none;">
                <div class="awards-grid">
                    <div class="award-section">
                        <h3><span class="award-icon">👑</span> Regular Season Champion (Most Wins)</h3>
                        <div class="award-table-wrapper">
                            <table class="award-table">
                                <thead>
                                    <tr>
                                        <th>Year</th>
                                        <th>Manager</th>
                                        <th>Team Name</th>
                                        <th>Wins</th>
                                    </tr>
                                </thead>
                                <tbody id="regular-season-winners">
                                </tbody>
                            </table>
                        </div>
                    </div>

                    <div class="award-section">
                        <h3><span class="award-icon">🏅</span> Scoring Champion (Most Points)</h3>
                        <div class="award-table-wrapper">
                            <table class="award-table">
                                <thead>
                                    <tr>
                                        <th>Year</th>
                                        <th>Manager</th>
                                        <th>Team Name</th>
                                        <th>Points</th>
                                    </tr>
                                </thead>
                                <tbody id="scoring-champions">
                                </tbody>
                            </table>
                        </div>
                    </div>

                    <div class="award-section">
                        <h3><span class="award-icon">🗑️</span> Garbage Award (Worst Record)</h3>
                        <div class="award-table-wrapper">
                            <table class="award-table">
                                <thead>
                                    <tr>
                                        <th>Year</th>
                                        <th>Manager</th>
                                        <th>Team Name</th>
                                        <th>Record</th>
                                    </tr>
                                </thead>
                                <tbody id="garbage-awards">
                                </tbody>
                            </table>
                        </div>
                    </div>

                    <div class="award-section">
                        <h3><span class="award-icon"><img src="clown_award.png" alt="Clown Award"
                                    class="award-header-image"></span> Clown Award (Least Points)</h3>
                        <div class="award-table-wrapper">
                            <table class="award-table">
                                <thead>
                                    <tr>
                                        <th>Year</th>
                                        <th>Manager</th>
                                        <th>Team Name</th>
                                        <th>Points</th>
                                    </tr>
                                </thead>
                                <tbody id="clown-awards">
                                </tbody>
                            </table>
                        </div>
                    </div>

                    <div class="award-section">
                        <h3><span class="award-icon"><img src="attached_assets/trout_award_1764648146923.png"
                                    alt="Mike Trout Award" class="award-header-image"></span> Mike Trout Award (Highest
                            Scoring Hitter)</h3>
                        <div class="award-table-wrapper">
                            <table class="award-table player-award-table">
                                <thead>
                                    <tr>
                                        <th>Year</th>
                                        <th>Manager</th>
                                        <th>Player</th>
                                        <th>Points</th>
                                    </tr>
                                </thead>
                                <tbody id="trout-awards">
                                </tbody>
                            </table>
                        </div>
                    </div>

                    <div class="award-section">
                        <h3><span class="award-icon"><img src="attached_assets/degom_award_1764648146918.png"
                                    alt="Jacob deGrom Award" class="award-header-image"></span> Jacob deGrom Award
                            (Highest Scoring Pitcher)</h3>
                        <div class="award-table-wrapper">
                            <table class="award-table player-award-table">
                                <thead>
                                    <tr>
                                        <th>Year</th>
                                        <th>Manager</th>
                                        <th>Player</th>
                                        <th>Points</th>
                                    </tr>
                                </thead>
                                <tbody id="degrom-awards">
                                </tbody>
                            </table>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Hall of Champions Section -->
        <div id="champions" class="section">
            <h2>🏆 Hall of Champions</h2>

            <div class="season-selector">
                <label for="champions-season">Select Championship Season:</label>
                <select id="champions-season" onchange="loadChampionData()">
                    <!-- Will be populated dynamically -->
                </select>
            </div>

            <div id="champions-loading" class="loading">Loading champion data...</div>
            <div id="champions-error" class="error" style="display: none;"></div>

            <div id="champions-content" style="display: none;">
                <!-- Champion Header -->
                <div id="champion-header" class="champion-header">
                    <!-- Will be populated dynamically -->
                </div>

                <!-- Championship Count Banner -->
                <div id="championship-count-banner" class="championship-count-banner">
                    <!-- Will show "1st Championship", "2nd Championship", etc. -->
                </div>

                <!-- Champion Stats Grid -->
                <div class="champion-stats-grid">
                    <div class="champion-stat-card">
                        <div class="stat-value" id="champion-record">-</div>
                        <div class="stat-label">Record</div>
                    </div>
                    <div class="champion-stat-card">
                        <div class="stat-value" id="champion-points">-</div>
                        <div class="stat-label">Total Points</div>
                    </div>
                    <div class="champion-stat-card">
                        <div class="stat-value" id="champion-ppg">-</div>
                        <div class="stat-label">Points/Week</div>
                    </div>
                    <div class="champion-stat-card">
                        <div class="stat-value" id="champion-best-week">-</div>
                        <div class="stat-label">Best Week</div>
                    </div>
                </div>

                <!-- Season Schedule -->
                <div class="champion-section">
                    <h3>📅 Season Schedule</h3>
                    <div class="table-wrapper">
                        <table class="champion-schedule-table">
                            <thead>
                                <tr>
                                    <th>Week</th>
                                    <th>Opponent</th>
                                    <th>Score</th>
                                    <th>Result</th>
                                </tr>
                            </thead>
                            <tbody id="champion-schedule">
                                <!-- Will be populated dynamically -->
                            </tbody>
                        </table>
                    </div>
                </div>

                <!-- Championship Roster -->
                <div class="champion-section">
                    <h3>⭐ Championship Roster</h3>
                    <div class="roster-grid" id="champion-roster">
                        <!-- Will be populated dynamically -->
                    </div>
                </div>
            </div>
        </div>

        <!-- Player Scoring Section -->
        <div id="scoring" class="section">
            <h2>Player Scoring</h2>

            <div class="player-controls">
                <div class="player-control-row">
                    <div class="season-selector">
                        <label for="scoring-season">Season:</label>
                        <select id="scoring-season" onchange="loadPlayerScoring()">
                            <!-- Will be populated dynamically -->
                        </select>
                    </div>

                    <div class="position-filter">
                        <label for="position-filter">Position:</label>
                        <select id="position-filter" onchange="filterPlayers()">
                            <option value="all">All Players</option>
                            <option value="B">All Batters</option>
                            <option value="P">All Pitchers</option>
                            <optgroup label="Batting Positions">
                                <option value="C">C - Catcher</option>
                                <option value="1B">1B - First Base</option>
                                <option value="2B">2B - Second Base</option>
                                <option value="3B">3B - Third Base</option>
                                <option value="SS">SS - Shortstop</option>
                                <option value="OF">OF - Outfield</option>
                                <option value="Util">Util - Utility</option>
                            </optgroup>
                            <optgroup label="Pitching Positions">
                                <option value="SP">SP - Starting Pitcher</option>
                                <option value="RP">RP - Relief Pitcher</option>
                            </optgroup>
                        </select>
                    </div>

                    <div class="manager-filter">
                        <label for="manager-filter">Manager:</label>
                        <select id="manager-filter" onchange="filterPlayers()">
                            <option value="all">All Managers</option>
                            <!-- Will be populated dynamically -->
                        </select>
                    </div>
                </div>

                <div class="player-search">
                    <input type="text" id="player-search" placeholder="Search players..." oninput="filterPlayers()">
                </div>
            </div>

            <div id="player-loading" class="loading">Loading player data...</div>
            <div id="player-error" class="error" style="display: none;"></div>

            <div id="player-stats-container" style="display: none;">
                <div class="player-summary">
                    <span id="player-count">0 players</span>
                </div>

                <div class="table-wrapper player-table-wrapper">
                    <table class="player-table" id="player-table">
                        <thead>
                            <tr>
                                <th class="sortable" onclick="sortPlayerTable('rank')">#</th>
                                <th class="sortable" onclick="sortPlayerTable('name')">Player</th>
                                <th>Team</th>
                                <th class="sortable" onclick="sortPlayerTable('position')">Pos</th>
                                <th class="sortable stat-col" onclick="sortPlayerTable('fantasy_points')">Pts</th>
                                <th class="sortable stat-col" onclick="sortPlayerTable('G')">G</th>
                                <th class="sortable stat-col" onclick="sortPlayerTable('PPG')">PPG</th>
                                <th class="sortable stat-col" onclick="sortPlayerTable('IP')">IP</th>
                                <th class="sortable stat-col" onclick="sortPlayerTable('ERA')">ERA</th>
                                <th class="sortable stat-col" onclick="sortPlayerTable('W')">W</th>
                                <th class="sortable stat-col" onclick="sortPlayerTable('SO')">K</th>
                                <th class="sortable stat-col" onclick="sortPlayerTable('BB')">BB</th>
                                <th class="sortable stat-col" onclick="sortPlayerTable('PA')">PA</th>
                                <th class="sortable stat-col" onclick="sortPlayerTable('HR')">HR</th>
                                <th class="sortable stat-col" onclick="sortPlayerTable('OPS')">OPS</th>
                            </tr>
                        </thead>
                        <tbody id="player-table-body">
                        </tbody>
                    </table>
                </div>
            </div>
        </div>

        <!-- Player Detail Modal -->
        <div id="player-modal" class="modal">
            <div class="modal-content player-modal-content">
                <span class="modal-close" onclick="closePlayerModal()">&times;</span>
                <div id="player-modal-header">
                    <!-- Header loaded dynamically -->
                </div>
                <div class="modal-body-scroll" id="player-modal-body">
                    <!-- Body content loaded dynamically -->
                </div>
            </div>
        </div>

        <!-- Manager Profiles Section -->
        <div id="managers" class="section">
            <h2>Manager Profiles</h2>

            <div id="managers-loading" class="loading">Loading manager profiles...</div>
            <div id="managers-error" class="error" style="display: none;"></div>

            <div class="manager-grid" id="manager-grid">
            </div>

            <!-- Win Percentage Over Time Chart -->
            <div id="winpct-chart-container" style="display: none; margin-top: 2rem;">
                <h3 style="color: #1e3c72; margin-bottom: 1rem;">📈 Win Percentage Over Time</h3>
                <div id="winpct-chart" style="width: 100%; overflow-x: auto; background: white; border-radius: 8px; padding: 1rem; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
                </div>
            </div>
        </div>
    </div>

    <!-- Manager Detail Modal -->
    <div id="manager-modal" class="modal">
        <div class="modal-content">
            <span class="modal-close" onclick="closeManagerModal()">&times;</span>
            <div id="modal-header-section">
                <!-- Header loaded dynamically -->
            </div>
            <div class="modal-body-scroll" id="modal-body">
                <!-- Body content loaded dynamically -->
            </div>
        </div>
    </div>

    <footer>
        <p>&copy; 2024 Yahoo Fantasy Baseball League | Powered by Python & Yahoo Fantasy API</p>
    </footer>

    <script>
        // ===== GLOBAL STATE =====
        let availableSeasons = [];
        let allManagersData = [];
        let managerHistoryData = [];
        let managerAwardsData = {}; // Store manager awards globally
        let currentTableMode = 'all'; // 'all', 'batters', or 'pitchers'

        // Player scoring state
        let allPlayersData = [];
        let filteredPlayersData = [];
        let playerHistoryData = {};
        let currentPlayerSort = { column: 'fantasy_points', direction: 'desc' };

        // Chart state
        let currentChartData = null;
        let currentChartType = 'weekly'; // 'weekly' or 'total'

        // Cache for team data to avoid redundant fetches
        const teamDataCache = {};
        
        // Cache for player stats data to avoid redundant fetches for rank calculations
        const playerStatsCache = {};

        // Helper function to get player stats data with caching
        async function getPlayerStatsData(year) {
            const cacheKey = year === 2025 ? 'current' : year;

            if (playerStatsCache[cacheKey]) {
                return playerStatsCache[cacheKey];
            }

            try {
                let statsPath = year === 2025 
                    ? 'data/current_season/player_stats.json'
                    : `data/historical/${year}/player_stats.json`;
                const response = await fetch(statsPath);
                if (response.ok) {
                    const data = await response.json();
                    playerStatsCache[cacheKey] = data;
                    return data;
                }
            } catch (e) {
                console.log(`Could not load player stats for ${year}`);
            }
            return null;
        }

        // Helper function to get team data with caching
        async function getTeamData(year) {
            const cacheKey = year === 2025 ? 'current' : year;

            if (teamDataCache[cacheKey]) {
                return teamDataCache[cacheKey];
            }

            try {
                let teamsResponse;
                if (year === 2025) {
                    teamsResponse = await fetch('data/current_season/teams.json');
                } else {
                    teamsResponse = await fetch(`data/historical/${year}/teams.json`);
                }

                if (teamsResponse.ok) {
                    const teams = await teamsResponse.json();
                    teamDataCache[cacheKey] = teams;
                    return teams;
                }
            } catch (e) {
                console.log(`Could not load team data for ${year}`);
            }

            return null;
        }

        // ===== PLAYER SCORING FUNCTIONS =====

        async function loadPlayerScoring() {
            const seasonSelect = document.getElementById('scoring-season');
            const selectedYear = parseInt(seasonSelect.value);

            const loadingEl = document.getElementById('player-loading');
            const errorEl = document.getElementById('player-error');
            const containerEl = document.getElementById('player-stats-container');

            loadingEl.style.display = 'block';
            errorEl.style.display = 'none';
            containerEl.style.display = 'none';

            try {
                // Determine the path based on year
                let playerStatsPath;
                if (selectedYear === 2025) {
                    playerStatsPath = 'data/current_season/player_stats.json';
                } else {
                    playerStatsPath = `data/historical/${selectedYear}/player_stats.json`;
                }

                const response = await fetch(playerStatsPath);
                if (!response.ok) {
                    throw new Error(`No player data available for ${selectedYear}`);
                }

                allPlayersData = await response.json();

                // Calculate position ranks for each player
                calculatePositionRanks();

                // Populate manager filter
                populateManagerFilter();

                // Apply filters and render
                filterPlayers();

                loadingEl.style.display = 'none';
                containerEl.style.display = 'block';

            } catch (error) {
                console.error('Error loading player data:', error);
                loadingEl.style.display = 'none';
                errorEl.textContent = `Error: ${error.message}`;
                errorEl.style.display = 'block';
            }
        }

        function calculatePositionRanks() {
            // Define all positions to rank
            const positions = ['C', '1B', '2B', '3B', 'SS', 'OF', 'Util', 'SP', 'RP', 'P'];
            
            // For each position, sort eligible players by fantasy points and assign ranks
            positions.forEach(pos => {
                // Get players eligible for this position
                let eligiblePlayers;
                if (pos === 'P') {
                    // P includes all pitchers
                    eligiblePlayers = allPlayersData.filter(p => p.position_type === 'P');
                } else {
                    eligiblePlayers = allPlayersData.filter(p => 
                        p.eligible_positions && p.eligible_positions.includes(pos)
                    );
                }
                
                // Sort by fantasy points descending
                eligiblePlayers.sort((a, b) => (b.fantasy_points || 0) - (a.fantasy_points || 0));
                
                // Assign ranks
                eligiblePlayers.forEach((player, index) => {
                    if (!player.position_ranks) {
                        player.position_ranks = {};
                    }
                    player.position_ranks[pos] = index + 1;
                });
            });
            
            // Also calculate overall batter and pitcher ranks
            const batters = allPlayersData.filter(p => p.position_type === 'B')
                .sort((a, b) => (b.fantasy_points || 0) - (a.fantasy_points || 0));
            batters.forEach((player, index) => {
                if (!player.position_ranks) player.position_ranks = {};
                player.position_ranks['B'] = index + 1;
            });
            
            const pitchers = allPlayersData.filter(p => p.position_type === 'P')
                .sort((a, b) => (b.fantasy_points || 0) - (a.fantasy_points || 0));
            pitchers.forEach((player, index) => {
                if (!player.position_ranks) player.position_ranks = {};
                player.position_ranks['P'] = index + 1;
            });
        }

        function getPositionWithRank(player) {
            const positionFilter = document.getElementById('position-filter').value;
            const pos = player.primary_position || '-';
            
            if (!player.position_ranks) return pos;
            
            // Determine which position rank to show based on filter
            let rankPos;
            let displayPos;
            
            if (positionFilter === 'all') {
                // Show primary position rank
                rankPos = pos;
                displayPos = pos;
            } else if (positionFilter === 'B') {
                // Show overall batter rank with primary position
                rankPos = 'B';
                displayPos = pos;
            } else if (positionFilter === 'P') {
                // Show overall pitcher rank with primary position
                rankPos = 'P';
                displayPos = pos;
            } else {
                // Specific position filter - show that position's rank
                rankPos = positionFilter;
                displayPos = positionFilter;
            }
            
            const rank = player.position_ranks[rankPos];
            if (rank) {
                return `${displayPos}${rank}`;
            }
            return pos;
        }

        function populateManagerFilter() {
            const managerFilter = document.getElementById('manager-filter');
            const managers = [...new Set(allPlayersData.map(p => p.manager))].sort();

            // Keep the "All Managers" option and add the rest
            managerFilter.innerHTML = '<option value="all">All Managers</option>';
            managers.forEach(manager => {
                const option = document.createElement('option');
                option.value = manager;
                option.textContent = manager;
                managerFilter.appendChild(option);
            });
        }

        function filterPlayers() {
            const positionFilter = document.getElementById('position-filter').value;
            const managerFilter = document.getElementById('manager-filter').value;
            const searchQuery = document.getElementById('player-search').value.toLowerCase().trim();

            // 1. DETERMINE TABLE MODE
            if (positionFilter === 'P' || positionFilter === 'SP' || positionFilter === 'RP') {
                currentTableMode = 'pitchers';
            } else if (positionFilter === 'B' || ['C', '1B', '2B', '3B', 'SS', 'OF', 'Util'].includes(positionFilter)) {
                currentTableMode = 'batters';
            } else {
                currentTableMode = 'all';
            }

            filteredPlayersData = allPlayersData.filter(player => {
                // Position filter
                if (positionFilter !== 'all') {
                    if (positionFilter === 'B' || positionFilter === 'P') {
                        if (player.position_type !== positionFilter) return false;
                    } else {
                        // Specific position
                        if (!player.eligible_positions.includes(positionFilter)) return false;
                    }
                }

                // Manager filter
                if (managerFilter !== 'all' && player.manager !== managerFilter) {
                    return false;
                }

                // Search filter
                if (searchQuery) {
                    const nameMatch = player.name.toLowerCase().includes(searchQuery);
                    const teamMatch = player.team_name.toLowerCase().includes(searchQuery);
                    const mlbMatch = (player.mlb_team || '').toLowerCase().includes(searchQuery);
                    if (!nameMatch && !teamMatch && !mlbMatch) return false;
                }

                return true;
            });

            // Apply current sort
            sortPlayersArray();

            // 2. REBUILD HEADERS BASED ON MODE
            updateTableHeaders();

            // Render the table
            renderPlayerTable();
        }

        function updateTableHeaders() {
            const thead = document.querySelector('#player-table thead');
            let headerHTML = `
                <tr>
                    <th class="sortable" onclick="sortPlayerTable('rank')">#</th>
                    <th class="sortable" onclick="sortPlayerTable('name')">Player</th>
                    <th>Team</th>
                    <th class="sortable" onclick="sortPlayerTable('position')">Pos</th>
            `;

            if (currentTableMode === 'batters') {
                // BATTER SPECIFIC HEADERS
                headerHTML += `
                    <th class="sortable stat-col" onclick="sortPlayerTable('fantasy_points')">Pts</th>
                    <th class="sortable stat-col" onclick="sortPlayerTable('G')">G</th>
                    <th class="sortable stat-col" onclick="sortPlayerTable('PPG')">PPG</th>
                    <th class="sortable stat-col" onclick="sortPlayerTable('AVG')">AVG</th>
                    <th class="sortable stat-col" onclick="sortPlayerTable('OPS')">OPS</th>
                    <th class="sortable stat-col" onclick="sortPlayerTable('AB')">AB</th>
                    <th class="sortable stat-col" onclick="sortPlayerTable('H')">H</th>
                    <th class="sortable stat-col" onclick="sortPlayerTable('HR')">HR</th>
                    <th class="sortable stat-col" onclick="sortPlayerTable('RBI')">RBI</th>
                    <th class="sortable stat-col" onclick="sortPlayerTable('SB')">SB</th>
                `;
            } else if (currentTableMode === 'pitchers') {
                // PITCHER SPECIFIC HEADERS
                headerHTML += `
                    <th class="sortable stat-col" onclick="sortPlayerTable('fantasy_points')">Pts</th>
                    <th class="sortable stat-col" onclick="sortPlayerTable('G')">G</th>
                    <th class="sortable stat-col" onclick="sortPlayerTable('GS')">GS</th>
                    <th class="sortable stat-col" onclick="sortPlayerTable('PPG')">PPG</th>
                    <th class="sortable stat-col" onclick="sortPlayerTable('IP')">IP</th>
                    <th class="sortable stat-col" onclick="sortPlayerTable('ERA')">ERA</th>
                    <th class="sortable stat-col" onclick="sortPlayerTable('WHIP')">WHIP</th>
                    <th class="sortable stat-col" onclick="sortPlayerTable('SO')">K</th>
                    <th class="sortable stat-col" onclick="sortPlayerTable('K%')">K%</th>
                    <th class="sortable stat-col" onclick="sortPlayerTable('BB')">BB</th>
                    <th class="sortable stat-col" onclick="sortPlayerTable('BB%')">BB%</th>
                    <th class="sortable stat-col" onclick="sortPlayerTable('W')">W</th>
                    <th class="sortable stat-col" onclick="sortPlayerTable('SV')">SV</th>
                `;
            } else {
                // ALL PLAYERS (DEFAULT) HEADERS
                headerHTML += `
                    <th class="sortable stat-col" onclick="sortPlayerTable('fantasy_points')">Pts</th>
                    <th class="sortable stat-col" onclick="sortPlayerTable('G')">G</th>
                    <th class="sortable stat-col" onclick="sortPlayerTable('PPG')">PPG</th>
                    <th class="sortable stat-col" onclick="sortPlayerTable('IP')">IP</th>
                    <th class="sortable stat-col" onclick="sortPlayerTable('ERA')">ERA</th>
                    <th class="sortable stat-col" onclick="sortPlayerTable('W')">W</th>
                    <th class="sortable stat-col" onclick="sortPlayerTable('SO')">K</th>
                    <th class="sortable stat-col" onclick="sortPlayerTable('BB')">BB</th>
                    <th class="sortable stat-col" onclick="sortPlayerTable('PA')">PA</th>
                    <th class="sortable stat-col" onclick="sortPlayerTable('HR')">HR</th>
                    <th class="sortable stat-col" onclick="sortPlayerTable('OPS')">OPS</th>
                `;
            }

            headerHTML += `</tr>`;
            thead.innerHTML = headerHTML;
        }

        function sortPlayerTable(column) {
            // Toggle direction if same column
            if (currentPlayerSort.column === column) {
                currentPlayerSort.direction = currentPlayerSort.direction === 'asc' ? 'desc' : 'asc';
            } else {
                currentPlayerSort.column = column;
                // Default to descending for stats, ascending for name
                currentPlayerSort.direction = (column === 'name' || column === 'position') ? 'asc' : 'desc';
            }

            sortPlayersArray();
            renderPlayerTable();
            updateSortIndicators();
        }

        function sortPlayersArray() {
            const { column, direction } = currentPlayerSort;

            filteredPlayersData.sort((a, b) => {
                let aVal, bVal;

                if (column === 'rank') {
                    // Rank is determined by fantasy points
                    aVal = a.fantasy_points || 0;
                    bVal = b.fantasy_points || 0;
                } else if (column === 'name') {
                    aVal = a.name.toLowerCase();
                    bVal = b.name.toLowerCase();
                } else if (column === 'position') {
                    aVal = a.primary_position || '';
                    bVal = b.primary_position || '';
                } else if (column === 'fantasy_points') {
                    aVal = a.fantasy_points || 0;
                    bVal = b.fantasy_points || 0;
                } else if (column === 'PPG') {
                    // Points Per Game = fantasy_points / G
                    const aGames = (a.stats && a.stats.G) || 0;
                    const bGames = (b.stats && b.stats.G) || 0;
                    aVal = aGames > 0 ? (a.fantasy_points || 0) / aGames : 0;
                    bVal = bGames > 0 ? (b.fantasy_points || 0) / bGames : 0;
                } else {
                    // Stat column
                    aVal = (a.stats && a.stats[column]) || 0;
                    bVal = (b.stats && b.stats[column]) || 0;
                }

                if (typeof aVal === 'string') {
                    return direction === 'asc' ? aVal.localeCompare(bVal) : bVal.localeCompare(aVal);
                }

                return direction === 'asc' ? aVal - bVal : bVal - aVal;
            });
        }

        function updateSortIndicators() {
            // Remove all sort indicators
            document.querySelectorAll('.player-table th').forEach(th => {
                th.classList.remove('sort-asc', 'sort-desc');
            });

            // Add indicator to current sort column
            const headers = document.querySelectorAll('.player-table th');
            headers.forEach(th => {
                const onclick = th.getAttribute('onclick');
                if (onclick && onclick.includes(`'${currentPlayerSort.column}'`)) {
                    th.classList.add(currentPlayerSort.direction === 'asc' ? 'sort-asc' : 'sort-desc');
                }
            });
        }

        function renderPlayerTable() {
            const tbody = document.getElementById('player-table-body');
            const countEl = document.getElementById('player-count');

            countEl.textContent = `${filteredPlayersData.length} player${filteredPlayersData.length !== 1 ? 's' : ''}`;

            if (filteredPlayersData.length === 0) {
                tbody.innerHTML = '<tr><td colspan="15" style="text-align: center; padding: 2rem; color: #666;">No players found matching your criteria</td></tr>';
                return;
            }

            // Base64 encoded placeholder
            const placeholderImg = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIj48cmVjdCB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCIgZmlsbD0iI2UwZTBlMCIvPjxjaXJjbGUgY3g9IjUwIiBjeT0iMzUiIHI9IjIwIiBmaWxsPSIjYmRiZGJkIi8+PGVsbGlwc2UgY3g9IjUwIiBjeT0iODUiIHJ4PSIzMCIgcnk9IjIwIiBmaWxsPSIjYmRiZGJkIi8+PC9zdmc+';

            tbody.innerHTML = filteredPlayersData.map((player, index) => {
                const stats = player.stats || {};
                const isBatter = player.position_type === 'B';
                const headshot = (player.headshot_url && player.headshot_url.trim()) ? player.headshot_url : placeholderImg;

                // Calculate PPG
                const games = stats.G || 0;
                const fantasyPoints = player.fantasy_points || 0;
                const ppg = games > 0 ? (fantasyPoints / games).toFixed(2) : '-';

                // Common cells (Rank, Name, Team, Pos)
                let rowHTML = `
                    <tr>
                        <td>${index + 1}</td>
                        <td>
                            <div class="player-name-cell" onclick="showPlayerDetail('${player.name.replace(/'/g, "\\'")}')">
                                <img src="${headshot}" alt="" class="player-headshot" onerror="this.src='${placeholderImg}'">
                                <div>
                                    <div class="player-name">${player.name}</div>
                                    <div class="player-mlb-team">${player.mlb_team || ''}</div>
                                </div>
                            </div>
                        </td>
                        <td>
                            <div class="player-team-cell">
                                <img src="${player.team_logo}" alt="" class="player-team-logo" onerror="this.style.display='none'">
                                <span class="player-fantasy-team" title="${player.team_name}">${player.manager}</span>
                            </div>
                        </td>
                        <td class="player-position">${getPositionWithRank(player)}</td>
                `;

                // STAT CELLS BASED ON MODE
                if (currentTableMode === 'batters') {
                    rowHTML += `
                        <td class="player-points">${fantasyPoints.toFixed(1)}</td>
                        <td class="stat-col">${games || '-'}</td>
                        <td class="stat-col">${ppg}</td>
                        <td class="stat-col">${stats.AVG ? stats.AVG.toFixed(3) : '-'}</td>
                        <td class="stat-col">${stats.OPS ? stats.OPS.toFixed(3) : '-'}</td>
                        <td class="stat-col">${stats.AB || '-'}</td>
                        <td class="stat-col">${stats.H || '-'}</td>
                        <td class="stat-col">${stats.HR || '-'}</td>
                        <td class="stat-col">${stats.RBI || '-'}</td>
                        <td class="stat-col">${stats.SB || '-'}</td>
                    `;
                } else if (currentTableMode === 'pitchers') {
                    rowHTML += `
                        <td class="player-points">${fantasyPoints.toFixed(1)}</td>
                        <td class="stat-col">${games || '-'}</td>
                        <td class="stat-col">${stats.GS || '-'}</td>
                        <td class="stat-col">${ppg}</td>
                        <td class="stat-col">${stats.IP || '-'}</td>
                        <td class="stat-col">${stats.ERA ? stats.ERA.toFixed(2) : '-'}</td>
                        <td class="stat-col">${stats.WHIP ? stats.WHIP.toFixed(2) : '-'}</td>
                        <td class="stat-col">${stats.SO || '-'}</td>
                        <td class="stat-col">${stats['K%'] ? stats['K%'].toFixed(1) : '-'}</td>
                        <td class="stat-col">${stats.BB || '-'}</td>
                        <td class="stat-col">${stats['BB%'] ? stats['BB%'].toFixed(1) : '-'}</td>
                        <td class="stat-col">${stats.W || '-'}</td>
                        <td class="stat-col">${stats.SV || '-'}</td>
                    `;
                } else {
                    // ALL PLAYERS
                    rowHTML += `
                        <td class="player-points">${fantasyPoints.toFixed(1)}</td>
                        <td class="stat-col">${games || '-'}</td>
                        <td class="stat-col">${ppg}</td>
                        <td class="stat-col">${!isBatter ? (stats.IP || '-') : '-'}</td>
                        <td class="stat-col">${!isBatter ? (stats.ERA ? stats.ERA.toFixed(2) : '-') : '-'}</td>
                        <td class="stat-col">${!isBatter ? (stats.W || '-') : '-'}</td>
                        <td class="stat-col">${!isBatter ? (stats.SO || '-') : '-'}</td>
                        <td class="stat-col">${stats.BB || '-'}</td>
                        <td class="stat-col">${isBatter ? (stats.PA || '-') : '-'}</td>
                        <td class="stat-col">${isBatter ? (stats.HR || '-') : '-'}</td>
                        <td class="stat-col">${isBatter ? (stats.OPS ? stats.OPS.toFixed(3) : '-') : '-'}</td>
                    `;
                }

                rowHTML += `</tr>`;
                return rowHTML;
            }).join('');

            updateSortIndicators();
        }

        // MLB Team abbreviation to ESPN CDN logo mapping
        function getMLBTeamLogo(mlbTeam, playerPosition) {
            if (!mlbTeam) return null;
            
            // Normalize input
            const team = mlbTeam.trim();
            
            // Direct abbreviation mappings (most reliable)
            // Covers both Fangraphs and Yahoo abbreviation styles
            const abbreviationMap = {
                // American League East
                'BAL': 'bal', 'BOS': 'bos', 'NYY': 'nyy', 'TB': 'tb', 'TBR': 'tb', 'TAM': 'tb', 'TOR': 'tor',
                // American League Central  
                'CWS': 'chw', 'CHW': 'chw', 'CLE': 'cle', 'DET': 'det', 'KC': 'kc', 'KCR': 'kc', 'MIN': 'min',
                // American League West
                'HOU': 'hou', 'LAA': 'laa', 'ANA': 'laa', 'OAK': 'oak', 'SEA': 'sea', 'TEX': 'tex',
                // National League East
                'ATL': 'atl', 'MIA': 'mia', 'FLA': 'mia', 'NYM': 'nym', 'PHI': 'phi', 'WSH': 'wsh', 'WAS': 'wsh', 'WSN': 'wsh',
                // National League Central
                'CHC': 'chc', 'CIN': 'cin', 'MIL': 'mil', 'PIT': 'pit', 'STL': 'stl',
                // National League West
                'ARI': 'ari', 'AZ': 'ari', 'COL': 'col', 'LAD': 'lad', 'SD': 'sd', 'SDP': 'sd', 'SF': 'sf', 'SFG': 'sf'
            };
            
            // Check abbreviation first
            if (abbreviationMap[team]) {
                return `https://a.espncdn.com/i/teamlogos/mlb/500/${abbreviationMap[team]}.png`;
            }
            
            // Nickname mappings (unambiguous)
            const nicknameMap = {
                'Orioles': 'bal', 'Red Sox': 'bos', 'Yankees': 'nyy', 'Rays': 'tb', 'Blue Jays': 'tor',
                'White Sox': 'chw', 'Guardians': 'cle', 'Indians': 'cle', 'Tigers': 'det', 'Royals': 'kc', 'Twins': 'min',
                'Astros': 'hou', 'Angels': 'laa', 'Athletics': 'oak', "A's": 'oak', 'Mariners': 'sea', 'Rangers': 'tex',
                'Braves': 'atl', 'Marlins': 'mia', 'Mets': 'nym', 'Phillies': 'phi', 'Nationals': 'wsh',
                'Cubs': 'chc', 'Reds': 'cin', 'Brewers': 'mil', 'Pirates': 'pit', 'Cardinals': 'stl',
                'Diamondbacks': 'ari', 'D-backs': 'ari', 'Rockies': 'col', 'Dodgers': 'lad', 'Padres': 'sd', 'Giants': 'sf'
            };
            
            // Check if team contains a nickname
            for (const [nickname, abbrev] of Object.entries(nicknameMap)) {
                if (team.includes(nickname)) {
                    return `https://a.espncdn.com/i/teamlogos/mlb/500/${abbrev}.png`;
                }
            }
            
            // Unambiguous city mappings
            const cityMap = {
                'Baltimore': 'bal', 'Boston': 'bos', 'Tampa Bay': 'tb', 'Toronto': 'tor',
                'Cleveland': 'cle', 'Detroit': 'det', 'Kansas City': 'kc', 'Minnesota': 'min',
                'Houston': 'hou', 'Oakland': 'oak', 'Seattle': 'sea', 'Texas': 'tex',
                'Atlanta': 'atl', 'Miami': 'mia', 'Philadelphia': 'phi', 'Washington': 'wsh',
                'Cincinnati': 'cin', 'Milwaukee': 'mil', 'Pittsburgh': 'pit', 'St. Louis': 'stl', 'St Louis': 'stl',
                'Arizona': 'ari', 'Colorado': 'col', 'San Diego': 'sd', 'San Francisco': 'sf'
            };
            
            // Check unambiguous cities
            for (const [city, abbrev] of Object.entries(cityMap)) {
                if (team.includes(city)) {
                    return `https://a.espncdn.com/i/teamlogos/mlb/500/${abbrev}.png`;
                }
            }
            
            // Handle ambiguous cities - use MLB logo as fallback or make best guess
            // New York, Los Angeles, Chicago all have 2 teams
            if (team === 'New York' || team === 'NY') {
                // Default to Yankees (more popular), but this is a guess
                return `https://a.espncdn.com/i/teamlogos/mlb/500/nyy.png`;
            }
            if (team === 'Los Angeles' || team === 'LA') {
                // Default to Dodgers (more popular)
                return `https://a.espncdn.com/i/teamlogos/mlb/500/lad.png`;
            }
            if (team === 'Chicago' || team === 'Chi') {
                // Default to Cubs (more popular)
                return `https://a.espncdn.com/i/teamlogos/mlb/500/chc.png`;
            }
            
            return null;
        }

        async function showPlayerDetail(playerName) {
            const modal = document.getElementById('player-modal');
            const headerEl = document.getElementById('player-modal-header');
            const bodyEl = document.getElementById('player-modal-body');

            // Find player in current data
            const player = allPlayersData.find(p => p.name === playerName);
            if (!player) return;

            const seasonSelect = document.getElementById('scoring-season');
            const selectedYear = parseInt(seasonSelect.value);

            // Load player history if not cached
            if (Object.keys(playerHistoryData).length === 0) {
                try {
                    const historyResponse = await fetch('data/players/player_history.json');
                    if (historyResponse.ok) {
                        playerHistoryData = await historyResponse.json();
                    }
                } catch (e) {
                    console.log('Could not load player history');
                }
            }

            // Placeholders
            const placeholderHeadshot = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIj48cmVjdCB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCIgZmlsbD0iI2UwZTBlMCIvPjxjaXJjbGUgY3g9IjUwIiBjeT0iMzUiIHI9IjIwIiBmaWxsPSIjYmRiZGJkIi8+PGVsbGlwc2UgY3g9IjUwIiBjeT0iODUiIHJ4PSIzMCIgcnk9IjIwIiBmaWxsPSIjYmRiZGJkIi8+PC9zdmc+';
            const placeholderLogo = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIj48cmVjdCB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCIgZmlsbD0iIzFlM2M3MiIvPjx0ZXh0IHg9IjUwIiB5PSI1NSIgZm9udC1zaXplPSI0MCIgdGV4dC1hbmNob3I9Im1pZGRsZSIgZmlsbD0iI2ZmZiI+4pqB77iPPC90ZXh0Pjwvc3ZnPg==';

            const headshot = (player.headshot_url && player.headshot_url.trim()) ? player.headshot_url : placeholderHeadshot;
            const fantasyTeamLogo = player.team_logo || placeholderLogo;
            const mlbLogo = getMLBTeamLogo(player.mlb_team) || placeholderLogo;
            const stats = player.stats || {};
            const isBatter = player.position_type === 'B';
            const fantasyPts = (player.fantasy_points || 0).toFixed(1);

            // Calculate position rank for current season
            const primaryPos = player.primary_position;
            const samePos = allPlayersData
                .filter(p => p.eligible_positions && p.eligible_positions.includes(primaryPos))
                .sort((a, b) => (b.fantasy_points || 0) - (a.fantasy_points || 0));
            const posRank = samePos.findIndex(p => p.name === player.name) + 1;
            const posRankDisplay = posRank > 0 ? `${primaryPos}${posRank}` : primaryPos;

            // Clear header (we're using body for the card)
            headerEl.innerHTML = '';

            // Build baseball card HTML
            let cardHTML = `
            <div class="baseball-card">
                <div class="card-header">
                    <img src="${mlbLogo}" alt="" class="card-mlb-logo" onerror="this.style.display='none'">
                    <div class="card-player-name">${player.name}</div>
                </div>
                
                <div class="card-photo-section">
                    <img src="${fantasyTeamLogo}" alt="" class="card-team-logo-corner" onerror="this.style.display='none'">
                    <div class="card-stats-corner">
                        <div class="card-team-badge">${player.mlb_team || 'FA'}</div>
                        <div class="card-fantasy-points">
                            ${fantasyPts}
                            <span class="pts-label">PTS</span>
                        </div>
                        <div class="card-position-rank">${posRankDisplay}</div>
                    </div>
                    <div class="card-photo-frame">
                        <img src="${headshot}" alt="${player.name}" class="card-headshot" onerror="this.src='${placeholderHeadshot}'">
                        <div class="card-position-badge">${player.primary_position}</div>
                    </div>
                </div>

                <div class="card-info-strip">
                    <span>📊 ${selectedYear} Stats</span>
                    <span>${player.eligible_positions ? player.eligible_positions.join('/') : player.primary_position}</span>
                    <span>⚾ ${isBatter ? 'Batter' : 'Pitcher'}</span>
                </div>

                <div class="card-scrollable">
                    <div class="card-stats-section">
                        <div class="card-stats-title">${selectedYear} Season Statistics</div>`;

            if (isBatter) {
                cardHTML += `
                        <table class="card-stats-table">
                            <tr>
                                <th>G</th><th>AB</th><th>H</th><th>HR</th><th>RBI</th><th>R</th><th>SB</th>
                            </tr>
                            <tr>
                                <td>${stats.G || 0}</td>
                                <td>${stats.AB || 0}</td>
                                <td>${stats.H || 0}</td>
                                <td>${stats.HR || 0}</td>
                                <td>${stats.RBI || 0}</td>
                                <td>${stats.R || 0}</td>
                                <td>${stats.SB || 0}</td>
                            </tr>
                            <tr>
                                <th>BB</th><th>2B</th><th>3B</th><th>AVG</th><th>OBP</th><th>SLG</th><th>OPS</th>
                            </tr>
                            <tr>
                                <td>${stats.BB || 0}</td>
                                <td>${stats['2B'] || 0}</td>
                                <td>${stats['3B'] || 0}</td>
                                <td>${stats.AVG ? stats.AVG.toFixed(3) : '.000'}</td>
                                <td>${stats.OBP ? stats.OBP.toFixed(3) : '.000'}</td>
                                <td>${stats.SLG ? stats.SLG.toFixed(3) : '.000'}</td>
                                <td>${stats.OPS ? stats.OPS.toFixed(3) : '.000'}</td>
                            </tr>
                        </table>`;
            } else {
                cardHTML += `
                        <table class="card-stats-table">
                            <tr>
                                <th>W</th><th>L</th><th>SV</th><th>G</th><th>GS</th><th>IP</th><th>K</th>
                            </tr>
                            <tr>
                                <td>${stats.W || 0}</td>
                                <td>${stats.L || 0}</td>
                                <td>${stats.SV || 0}</td>
                                <td>${stats.G || 0}</td>
                                <td>${stats.GS || 0}</td>
                                <td>${stats.IP || 0}</td>
                                <td>${stats.SO || 0}</td>
                            </tr>
                            <tr>
                                <th>BB</th><th>ERA</th><th>WHIP</th><th>K/9</th><th>K%</th><th>BB%</th><th>HLD</th>
                            </tr>
                            <tr>
                                <td>${stats.BB || 0}</td>
                                <td>${stats.ERA ? stats.ERA.toFixed(2) : '0.00'}</td>
                                <td>${stats.WHIP ? stats.WHIP.toFixed(2) : '0.00'}</td>
                                <td>${stats['K/9'] ? stats['K/9'].toFixed(1) : '0.0'}</td>
                                <td>${stats['K%'] ? stats['K%'].toFixed(0) : '0'}%</td>
                                <td>${stats['BB%'] ? stats['BB%'].toFixed(0) : '0'}%</td>
                                <td>${stats.HLD || 0}</td>
                            </tr>
                        </table>`;
            }

            cardHTML += `</div>`;

            // Career history section
            const normalizedName = playerName.toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g, '');
            const playerHistory = playerHistoryData[normalizedName];

            if (playerHistory && playerHistory.seasons && playerHistory.seasons.length > 0) {
                const historyLogos = {};
                const historyRanks = {};
                
                for (const season of playerHistory.seasons) {
                    const teams = await getTeamData(season.year);
                    if (teams) {
                        const team = teams.find(t => t.team_name === season.team_name);
                        if (team) {
                            historyLogos[`${season.year}_${season.team_name}`] = team.team_logo;
                        }
                    }
                    
                    const yearPlayers = await getPlayerStatsData(season.year);
                    if (yearPlayers) {
                        const sameType = yearPlayers
                            .filter(p => p.position_type === player.position_type)
                            .sort((a, b) => (b.fantasy_points || 0) - (a.fantasy_points || 0));
                        const overallRank = sameType.findIndex(p => p.name === player.name) + 1;
                        
                        const primaryPos = player.primary_position;
                        const samePos = yearPlayers
                            .filter(p => p.eligible_positions && p.eligible_positions.includes(primaryPos))
                            .sort((a, b) => (b.fantasy_points || 0) - (a.fantasy_points || 0));
                        const posRank = samePos.findIndex(p => p.name === player.name) + 1;
                        
                        historyRanks[season.year] = {
                            overall: overallRank > 0 ? overallRank : '-',
                            position: posRank > 0 ? `${primaryPos}${posRank}` : '-'
                        };
                    } else {
                        historyRanks[season.year] = { overall: '-', position: '-' };
                    }
                }

                cardHTML += `
                    <div class="card-history-section">
                        <div class="card-history-title">📜 League History</div>
                        <table class="card-history-table">
                            <thead>
                                <tr>
                                    <th>Year</th>
                                    <th>Team</th>
                                    <th>Pts</th>
                                    <th>Rk</th>
                                    <th>Pos</th>
                                </tr>
                            </thead>
                            <tbody>`;

                playerHistory.seasons.sort((a, b) => b.year - a.year).forEach(season => {
                    const logo = historyLogos[`${season.year}_${season.team_name}`] || '';
                    const ranks = historyRanks[season.year] || { overall: '-', position: '-' };
                    cardHTML += `
                                <tr>
                                    <td><strong>${season.year}</strong></td>
                                    <td>${logo ? `<img src="${logo}" class="team-logo-small" alt="">` : ''}${season.manager || ''}</td>
                                    <td>${(season.fantasy_points || 0).toFixed(0)}</td>
                                    <td>${ranks.overall}</td>
                                    <td>${ranks.position}</td>
                                </tr>`;
                });

                cardHTML += `
                            </tbody>
                        </table>
                    </div>`;
            }

            cardHTML += `</div>`; // Close card-scrollable

            // Footer with owner info
            cardHTML += `
                <div class="card-footer">
                    <div class="owner-info">
                        <span>Owned by:</span>
                        ${player.team_logo ? `<img src="${player.team_logo}" class="owner-logo" alt="">` : ''}
                        <strong>${player.manager || 'Free Agent'}</strong>
                        <span>•</span>
                        <span>${player.team_name || ''}</span>
                    </div>
                </div>
            </div>`; // Close baseball-card

            bodyEl.innerHTML = cardHTML;
            modal.classList.add('active');
        }

        function closePlayerModal() {
            document.getElementById('player-modal').classList.remove('active');
        }

        // Close player modal on outside click
        document.getElementById('player-modal')?.addEventListener('click', function (e) {
            if (e.target === this) {
                closePlayerModal();
            }
        });

        // ===== MANAGER NAME NORMALIZATION =====
        const MANAGER_TEAM_2023 = {
            "Draft Pool": "Logan C",
            "Peanut Butter & Elly": "Logan S"
        };

        // Logan team keys for 2023 disambiguation
        const LOGAN_TEAM_KEYS_2023 = {
            "422.l.6780.t.4": "Logan C",   // Draft Pool
            "422.l.6780.t.12": "Logan S"   // Peanut Butter & Elly
        };

        function normalizeManagerName(managerName, year = null, teamName = null, teamKey = null) {
            // Convert to title case
            let normalized = managerName.trim()
                .toLowerCase()
                .split(' ')
                .map(word => word.charAt(0).toUpperCase() + word.slice(1))
                .join(' ');

            // Handle Logan disambiguation
            if (normalized === "Logan") {
                if (year === 2023 && teamName && MANAGER_TEAM_2023[teamName]) {
                    return MANAGER_TEAM_2023[teamName];
                }
                if (year && year >= 2020 && year <= 2022) {
                    return "Logan C";
                } else if (year && year >= 2024) {
                    return "Logan S";
                }
            }

            // Handle Josh disambiguation (2019-2022)
            if (normalized === "Josh") {
                if (year && year >= 2019 && year <= 2022) {
                    if (teamKey && teamKey.endsWith('t.1')) {
                        return "Josh B";
                    } else {
                        return "Josh S";
                    }
                } else if (year && year >= 2023) {
                    // After 2022, only Josh B remains
                    if (teamKey && teamKey.endsWith('t.1')) {
                        return "Josh B";
                    }
                }
            }

            return normalized;
        }

        function normalizeStandingsData(standings, year) {
            return standings.map(team => ({
                ...team,
                manager: normalizeManagerName(team.manager, year, team.team_name, team.team_key)
            }));
        }

        function normalizeAndMergeManagerData(managersData, historyData) {
            const managerMap = {};

            console.log("Processing managers:", managersData.length);

            // Process each manager's data
            managersData.forEach(manager => {
                // Determine normalized name based on season history
                let normalizedName = manager.manager_name.trim()
                    .toLowerCase()
                    .split(' ')
                    .map(word => word.charAt(0).toUpperCase() + word.slice(1))
                    .join(' ');

                // Handle Logan based on team keys in 2023 or years active
                if (normalizedName === "Logan") {
                    console.log("Found Logan:", manager.season_history);

                    // Check if they have 2023 season
                    const season2023 = manager.season_history.find(s => s.year === 2023);

                    if (season2023) {
                        console.log("Logan has 2023, team:", season2023.team_name);
                        // Use team name to distinguish
                        if (season2023.team_name.includes("Draft Pool")) {
                            normalizedName = "Logan C";
                            console.log("-> Logan C (Draft Pool)");
                        } else if (season2023.team_name.includes("Peanut Butter") || season2023.team_name.includes("Elly")) {
                            normalizedName = "Logan S";
                            console.log("-> Logan S (Peanut Butter & Elly)");
                        } else {
                            console.log("-> Unknown team in 2023:", season2023.team_name);
                        }
                    } else {
                        // No 2023 season - use years to determine
                        const years = manager.season_history.map(s => s.year);
                        const maxYear = Math.max(...years);
                        const minYear = Math.min(...years);

                        console.log("Logan years:", years, "min:", minYear, "max:", maxYear);

                        if (maxYear <= 2022) {
                            // Only played 2020-2022 = Logan C
                            normalizedName = "Logan C";
                            console.log("-> Logan C (only 2020-2022)");
                        } else if (minYear >= 2024) {
                            // Only played 2024+ = Logan S
                            normalizedName = "Logan S";
                            console.log("-> Logan S (only 2024+)");
                        } else {
                            console.log("-> Logan with unclear years");
                        }
                    }
                }

                // Normalize season history
                const normalizedSeasonHistory = manager.season_history.map(season => ({
                    ...season
                }));

                // DON'T merge different Logans - only merge case variations
                const shouldMerge = managerMap[normalizedName] &&
                    !(normalizedName === "Logan C" || normalizedName === "Logan S");

                if (shouldMerge) {
                    console.log("Merging into existing manager:", normalizedName);
                    // Merge stats
                    managerMap[normalizedName].total_wins += manager.total_wins;
                    managerMap[normalizedName].total_losses += manager.total_losses;
                    managerMap[normalizedName].total_ties += manager.total_ties;
                    managerMap[normalizedName].total_points_for += manager.total_points_for;
                    managerMap[normalizedName].championships += manager.championships;
                    managerMap[normalizedName].runner_ups += manager.runner_ups;
                    managerMap[normalizedName].playoff_appearances += manager.playoff_appearances;
                    managerMap[normalizedName].seasons_played += manager.seasons_played;

                    // Merge season history
                    managerMap[normalizedName].season_history = [
                        ...managerMap[normalizedName].season_history,
                        ...normalizedSeasonHistory
                    ];

                    // Update first season
                    managerMap[normalizedName].first_season = Math.min(
                        managerMap[normalizedName].first_season,
                        manager.first_season
                    );
                } else {
                    console.log("Creating new manager entry:", normalizedName);
                    // New manager entry
                    managerMap[normalizedName] = {
                        ...manager,
                        manager_name: normalizedName,
                        season_history: normalizedSeasonHistory
                    };
                }
            });

            console.log("Final managers:", Object.keys(managerMap));

            // Recalculate derived stats for merged managers
            Object.values(managerMap).forEach(manager => {
                const totalGames = manager.total_wins + manager.total_losses;
                manager.win_pct = totalGames > 0 ? manager.total_wins / totalGames : 0;
                manager.avg_finish = manager.season_history.length > 0
                    ? manager.season_history.reduce((sum, s) => sum + s.rank, 0) / manager.season_history.length
                    : 0;

                // Sort season history by year
                manager.season_history.sort((a, b) => a.year - b.year);
            });

            return Object.values(managerMap);
        }

        // Split Logan's stats for 2023 based on team_key
        async function splitLogan2023Stats() {
            try {
                // Load 2023 standings and scores
                const standingsResponse = await fetch('data/historical/2023/final_standings.json');
                const scoresResponse = await fetch('data/historical/2023/all_scores.json');

                if (!standingsResponse.ok || !scoresResponse.ok) {
                    console.log("Could not load 2023 data for Logan split");
                    return null;
                }

                const standings = await standingsResponse.json();
                const scores = await scoresResponse.json();

                // Find Logan's teams by team_key
                const loganCTeam = standings.find(t => t.team_key === "422.l.6780.t.4");
                const loganSTeam = standings.find(t => t.team_key === "422.l.6780.t.12");

                if (!loganCTeam && !loganSTeam) {
                    console.log("Could not find Logan team keys in 2023 standings");
                    return null;
                }

                // Calculate stats for each Logan based on team_key
                const loganStats = {
                    "Logan C": loganCTeam ? {
                        team_key: loganCTeam.team_key,
                        team_name: loganCTeam.team_name,
                        rank: loganCTeam.rank,
                        wins: loganCTeam.wins,
                        losses: loganCTeam.losses,
                        ties: loganCTeam.ties,
                        points_for: loganCTeam.points_for
                    } : null,
                    "Logan S": loganSTeam ? {
                        team_key: loganSTeam.team_key,
                        team_name: loganSTeam.team_name,
                        rank: loganSTeam.rank,
                        wins: loganSTeam.wins,
                        losses: loganSTeam.losses,
                        ties: loganSTeam.ties,
                        points_for: loganSTeam.points_for
                    } : null
                };

                console.log("Split Logan 2023 stats:", loganStats);
                return loganStats;

            } catch (error) {
                console.error("Error splitting Logan stats:", error);
                return null;
            }
        }

        // Apply Logan split to manager data
        async function applyLogan2023Split(managersData) {
            const logan2023Stats = await splitLogan2023Stats();

            if (!logan2023Stats) {
                console.log("No Logan split needed or data unavailable");
                return managersData;
            }

            // Update each Logan's 2023 season data
            managersData.forEach(manager => {
                if ((manager.manager_name === "Logan C" || manager.manager_name === "Logan S") && logan2023Stats[manager.manager_name]) {
                    const season2023Index = manager.season_history.findIndex(s => s.year === 2023);

                    if (season2023Index >= 0) {
                        // Update with correct stats
                        const stats = logan2023Stats[manager.manager_name];
                        manager.season_history[season2023Index] = {
                            year: 2023,
                            team_name: stats.team_name,
                            rank: stats.rank,
                            wins: stats.wins,
                            losses: stats.losses,
                            points_for: stats.points_for
                        };

                        // Recalculate totals
                        manager.total_wins = manager.season_history.reduce((sum, s) => sum + s.wins, 0);
                        manager.total_losses = manager.season_history.reduce((sum, s) => sum + s.losses, 0);
                        manager.total_points_for = manager.season_history.reduce((sum, s) => sum + s.points_for, 0);
                        manager.win_pct = manager.total_wins / (manager.total_wins + manager.total_losses);
                        manager.avg_finish = manager.season_history.reduce((sum, s) => sum + s.rank, 0) / manager.season_history.length;

                        console.log(`Updated ${manager.manager_name} with 2023 stats`);
                    }
                }
            });

            return managersData;
        }

        // ===== INITIALIZE SEASON SELECTORS =====
        async function initializeSeasonSelectors() {
            const standingsSelect = document.getElementById('standings-season');
            standingsSelect.innerHTML = '<option value="">Loading seasons...</option>';

            // Try to detect available seasons by checking for data files
            const possibleSeasons = [2019, 2020, 2021, 2022, 2023, 2024, 2025];
            const availableSeasons = [];

            // Check current season
            try {
                const response = await fetch('data/current_season/standings.json');
                if (response.ok) {
                    availableSeasons.push({ year: 2025, isCurrent: true });
                }
            } catch (e) { }

            // Check historical seasons
            for (const year of possibleSeasons.filter(y => y < 2025)) {
                try {
                    const response = await fetch(`data/historical/${year}/final_standings.json`);
                    if (response.ok) {
                        availableSeasons.push({ year: year, isCurrent: false });
                    }
                } catch (e) { }
            }

            // Sort by year descending
            availableSeasons.sort((a, b) => b.year - a.year);

            // Populate dropdown
            standingsSelect.innerHTML = '';
            availableSeasons.forEach(season => {
                const option = document.createElement('option');
                option.value = season.year;
                option.textContent = season.isCurrent ? `${season.year} (Current)` : season.year;
                standingsSelect.appendChild(option);
            });

            // Populate scoring dropdown the same way
            const scoringSelect = document.getElementById('scoring-season');
            scoringSelect.innerHTML = standingsSelect.innerHTML;

            return availableSeasons;
        }

        // ===== LOAD STANDINGS BY SEASON =====
        async function loadStandingsBySeason() {
            const season = document.getElementById('standings-season').value;
            const loadingEl = document.getElementById('standings-loading');
            const errorEl = document.getElementById('standings-error');
            const tableEl = document.getElementById('standings-table');
            const chartContainer = document.getElementById('season-chart-container');

            if (!season) {
                return; // No season selected yet
            }

            try {
                loadingEl.style.display = 'block';
                errorEl.style.display = 'none';
                tableEl.style.display = 'none';
                chartContainer.style.display = 'none';

                let response;
                const seasonNum = parseInt(season);

                // Check if this is current season (2025) or historical
                const currentSeasonCheck = await fetch('data/current_season/standings.json');
                let isCurrentSeason = false;

                if (currentSeasonCheck.ok) {
                    // If current season data exists, it's 2025
                    isCurrentSeason = (seasonNum === 2025);
                }

                // Load from appropriate location
                if (isCurrentSeason) {
                    response = await fetch('data/current_season/standings.json');
                } else {
                    response = await fetch(`data/historical/${season}/final_standings.json`);
                }

                if (!response.ok) {
                    throw new Error(`Data not found for ${season}`);
                }

                let standings = await response.json();

                // Load team logos
                let teamsResponse;
                if (isCurrentSeason) {
                    teamsResponse = await fetch('data/current_season/teams.json');
                } else {
                    teamsResponse = await fetch(`data/historical/${season}/teams.json`);
                }

                let teamLogos = {};
                let teamData = [];
                if (teamsResponse.ok) {
                    teamData = await teamsResponse.json();
                    teamData.forEach(team => {
                        teamLogos[team.team_key] = team.team_logo;
                    });
                }

                // Normalize manager names
                standings = normalizeStandingsData(standings, seasonNum);

                // Sort by rank to ensure proper ordering
                standings.sort((a, b) => a.rank - b.rank);

                // Populate the table
                const tbody = document.getElementById('standings-body');
                tbody.innerHTML = '';

                standings.forEach(team => {
                    const row = document.createElement('tr');
                    const logo = teamLogos[team.team_key] ? `<img src="${teamLogos[team.team_key]}" class="team-logo" alt="Team Logo">` : '';

                    // Add medals for top 3
                    let medal = '';
                    if (team.rank === 1) medal = '<span class="medal">🥇</span>';
                    else if (team.rank === 2) medal = '<span class="medal">🥈</span>';
                    else if (team.rank === 3) medal = '<span class="medal">🥉</span>';

                    row.innerHTML = `
                        <td>${medal}${team.rank}</td>
                        <td><div class="manager-cell">${team.manager}</div></td>
                        <td><div class="team-cell-content">${logo}<span>${team.team_name}</span></div></td>
                        <td>${team.wins}</td>
                        <td>${team.losses}</td>
                        <td>${team.win_pct.toFixed(3)}</td>
                        <td>${Math.round(team.points_for).toLocaleString()}</td>
                    `;
                    tbody.appendChild(row);
                });

                loadingEl.style.display = 'none';
                tableEl.style.display = 'table';

                // Load and render the season chart
                await loadSeasonChart(seasonNum, isCurrentSeason, standings, teamLogos, teamData);

            } catch (error) {
                console.error('Error loading standings:', error);
                loadingEl.style.display = 'none';
                errorEl.textContent = `Error loading ${season} standings: ${error.message}`;
                errorEl.style.display = 'block';
            }
        }

        // ===== SEASON CHART FUNCTIONS =====
        async function loadSeasonChart(seasonNum, isCurrentSeason, standings, teamLogos, teamData) {
            const chartContainer = document.getElementById('season-chart-container');
            const chartEl = document.getElementById('season-chart');

            try {
                // Load weekly scores data
                let scoresResponse;
                if (isCurrentSeason) {
                    scoresResponse = await fetch('data/current_season/all_scores.json');
                } else {
                    scoresResponse = await fetch(`data/historical/${seasonNum}/all_scores.json`);
                }

                if (!scoresResponse.ok) {
                    console.log('No scores data available for chart');
                    chartContainer.style.display = 'none';
                    return;
                }

                const scoresData = await scoresResponse.json();
                console.log('Loaded scores data:', scoresData.length, 'entries');

                // Process scores into both weekly and cumulative rankings
                currentChartData = processScoresForChart(scoresData, standings, teamLogos, teamData);
                console.log('Processed chart data:', currentChartData.weeklyTeams.length, 'teams');

                if (currentChartData.weeklyTeams.length === 0) {
                    console.log('No team data to display');
                    chartContainer.style.display = 'none';
                    return;
                }

                // Reset to total view (default)
                currentChartType = 'total';
                document.getElementById('btn-weekly').classList.remove('active');
                document.getElementById('btn-total').classList.add('active');

                // Show container first so it has dimensions
                chartContainer.style.display = 'block';

                // Use requestAnimationFrame to ensure DOM is updated before rendering
                requestAnimationFrame(() => {
                    renderSeasonChart(chartEl, currentChartData, currentChartType);
                });

            } catch (error) {
                console.error('Error loading season chart:', error);
                chartContainer.style.display = 'none';
            }
        }

        function setChartType(type) {
            if (type === currentChartType || !currentChartData) return;

            currentChartType = type;

            // Update button states
            document.getElementById('btn-weekly').classList.toggle('active', type === 'weekly');
            document.getElementById('btn-total').classList.toggle('active', type === 'total');

            // Re-render chart
            const chartEl = document.getElementById('season-chart');
            renderSeasonChart(chartEl, currentChartData, currentChartType);
        }

        function processScoresForChart(scoresData, standings, teamLogos, teamData) {
            // Group scores by week first
            const weeklyScores = {};
            const teamInfo = {};

            // Collect all scores by week and team info
            scoresData.forEach(entry => {
                const teamKey = entry.team_key;
                const week = entry.week;
                const score = entry.team_score;

                // Store team info
                if (!teamInfo[teamKey]) {
                    const standingTeam = standings.find(t => t.team_key === teamKey);
                    const teamDataEntry = teamData.find(t => t.team_key === teamKey);

                    teamInfo[teamKey] = {
                        team_key: teamKey,
                        team_name: standingTeam?.team_name || teamDataEntry?.team_name || 'Unknown Team',
                        manager: standingTeam?.manager || teamDataEntry?.manager || 'Unknown',
                        logo: teamLogos[teamKey] || teamDataEntry?.team_logo || ''
                    };
                }

                // Store weekly score
                if (!weeklyScores[week]) {
                    weeklyScores[week] = [];
                }
                weeklyScores[week].push({
                    team_key: teamKey,
                    score: score
                });
            });

            const weeks = Object.keys(weeklyScores).map(Number).sort((a, b) => a - b);
            const numTeams = Object.keys(teamInfo).length;

            // Calculate WEEKLY rankings
            const teamWeeklyRankings = {};
            weeks.forEach(week => {
                const weekScores = [...weeklyScores[week]].sort((a, b) => b.score - a.score);
                weekScores.forEach((entry, index) => {
                    const rank = index + 1;
                    if (!teamWeeklyRankings[entry.team_key]) {
                        teamWeeklyRankings[entry.team_key] = [];
                    }
                    teamWeeklyRankings[entry.team_key].push({
                        week: week,
                        rank: rank,
                        score: entry.score
                    });
                });
            });

            // Calculate CUMULATIVE rankings
            const teamCumulativeScores = {}; // team_key -> running total
            const teamCumulativeRankings = {};

            weeks.forEach(week => {
                // Update cumulative scores
                weeklyScores[week].forEach(entry => {
                    if (!teamCumulativeScores[entry.team_key]) {
                        teamCumulativeScores[entry.team_key] = 0;
                    }
                    teamCumulativeScores[entry.team_key] += entry.score;
                });

                // Sort teams by cumulative score descending
                const cumulativeRanking = Object.entries(teamCumulativeScores)
                    .map(([teamKey, total]) => ({ team_key: teamKey, cumulative: total }))
                    .sort((a, b) => b.cumulative - a.cumulative);

                // Assign cumulative ranks
                cumulativeRanking.forEach((entry, index) => {
                    const rank = index + 1;
                    if (!teamCumulativeRankings[entry.team_key]) {
                        teamCumulativeRankings[entry.team_key] = [];
                    }
                    teamCumulativeRankings[entry.team_key].push({
                        week: week,
                        rank: rank,
                        cumulative: entry.cumulative
                    });
                });
            });

            // Build result arrays for both types
            const weeklyTeams = [];
            const cumulativeTeams = [];

            Object.keys(teamInfo).forEach(teamKey => {
                const info = teamInfo[teamKey];

                // Weekly data
                const weeklyData = (teamWeeklyRankings[teamKey] || []).sort((a, b) => a.week - b.week);
                const avgWeeklyRank = weeklyData.length > 0
                    ? weeklyData.reduce((sum, r) => sum + r.rank, 0) / weeklyData.length
                    : numTeams;

                weeklyTeams.push({
                    team_key: teamKey,
                    team_name: info.team_name,
                    manager: info.manager,
                    logo: info.logo,
                    data: weeklyData,
                    avgRank: avgWeeklyRank
                });

                // Cumulative data
                const cumulativeData = (teamCumulativeRankings[teamKey] || []).sort((a, b) => a.week - b.week);
                const finalRank = cumulativeData.length > 0
                    ? cumulativeData[cumulativeData.length - 1].rank
                    : numTeams;

                cumulativeTeams.push({
                    team_key: teamKey,
                    team_name: info.team_name,
                    manager: info.manager,
                    logo: info.logo,
                    data: cumulativeData,
                    finalRank: finalRank
                });
            });

            // Sort weekly by average rank, cumulative by final rank
            weeklyTeams.sort((a, b) => a.avgRank - b.avgRank);
            cumulativeTeams.sort((a, b) => a.finalRank - b.finalRank);

            console.log('Teams with ranking data:', weeklyTeams.length);
            console.log('Weeks:', weeks.length);

            return {
                weeklyTeams: weeklyTeams,
                cumulativeTeams: cumulativeTeams,
                numTeams: numTeams,
                weeks: weeks
            };
        }

        function renderSeasonChart(container, chartData, chartType) {
            // Clear previous chart
            container.innerHTML = '';

            const { weeklyTeams, cumulativeTeams, numTeams, weeks } = chartData;
            const teams = chartType === 'weekly' ? weeklyTeams : cumulativeTeams;
            const isWeekly = chartType === 'weekly';

            // Detect mobile
            const isMobile = window.innerWidth <= 768;

            // Chart dimensions - adjusted for mobile
            const containerWidth = container.clientWidth || container.offsetWidth || 900;
            const logoRadius = isMobile ? 10 : 14;
            const logoImageSize = isMobile ? 14 : 20;
            const rowHeight = isMobile ? 28 : 40;

            // On mobile, ensure minimum width for scrolling
            const minChartWidth = isMobile ? Math.max(weeks.length * 25, 600) : 600;

            const margin = { top: 30, right: 30, bottom: 50, left: isMobile ? 40 : 70 };
            const width = Math.max(minChartWidth, containerWidth - margin.left - margin.right);
            const height = Math.max(400, numTeams * rowHeight + 60);

            const minWeek = Math.min(...weeks);
            const maxWeek = Math.max(...weeks);
            const weekRange = maxWeek - minWeek || 1;

            // Scale functions
            const xScale = (week) => margin.left + ((week - minWeek) / weekRange) * width;
            const yScale = (rank) => margin.top + ((rank - 1) / (numTeams - 1)) * (height - margin.top - margin.bottom);

            // Generate colors for teams
            const colors = generateTeamColors(teams.length);
            const teamColorMap = {};
            teams.forEach((team, index) => {
                teamColorMap[team.team_key] = colors[index];
            });

            // Create SVG
            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.setAttribute('width', width + margin.left + margin.right);
            svg.setAttribute('height', height);
            svg.setAttribute('class', 'chart-svg');
            svg.style.display = 'block';
            // Don't limit width on mobile to allow scrolling
            if (!isMobile) {
                svg.style.maxWidth = '100%';
            }

            // Draw horizontal grid lines for each rank
            for (let rank = 1; rank <= numTeams; rank++) {
                const y = yScale(rank);
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', margin.left);
                line.setAttribute('y1', y);
                line.setAttribute('x2', margin.left + width);
                line.setAttribute('y2', y);
                line.setAttribute('class', 'chart-grid-line');
                line.setAttribute('stroke-dasharray', '3,3');
                svg.appendChild(line);

                // Y-axis rank label
                const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                label.setAttribute('x', margin.left - (isMobile ? 15 : 25));
                label.setAttribute('y', y + 4);
                label.setAttribute('text-anchor', 'end');
                label.setAttribute('class', 'chart-axis-label');
                label.setAttribute('font-size', isMobile ? '10px' : '12px');
                label.textContent = rank;
                svg.appendChild(label);
            }

            // Draw X-axis labels - show fewer on mobile
            const numWeeksTotal = weeks.length;
            const weekStep = Math.max(1, Math.ceil(numWeeksTotal / (isMobile ? 8 : 12)));
            for (let i = 0; i < weeks.length; i += weekStep) {
                const week = weeks[i];
                const x = xScale(week);
                const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                label.setAttribute('x', x);
                label.setAttribute('y', height - 10);
                label.setAttribute('text-anchor', 'middle');
                label.setAttribute('class', 'chart-axis-label');
                label.setAttribute('font-size', isMobile ? '10px' : '12px');
                label.textContent = `${week}`;
                svg.appendChild(label);
            }

            // X-axis title
            const xTitle = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            xTitle.setAttribute('x', margin.left + width / 2);
            xTitle.setAttribute('y', height - 0);
            xTitle.setAttribute('text-anchor', 'middle');
            xTitle.setAttribute('class', 'chart-axis-label');
            xTitle.setAttribute('font-weight', 'bold');
            xTitle.setAttribute('font-size', isMobile ? '11px' : '12px');
            xTitle.textContent = 'Week';
            svg.appendChild(xTitle);

            // Y-axis title
            const yTitle = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            yTitle.setAttribute('transform', `rotate(-90)`);
            yTitle.setAttribute('x', -(margin.top + (height - margin.top - margin.bottom) / 2));
            yTitle.setAttribute('y', isMobile ? 12 : 15);
            yTitle.setAttribute('text-anchor', 'middle');
            yTitle.setAttribute('class', 'chart-axis-label');
            yTitle.setAttribute('font-weight', 'bold');
            yTitle.setAttribute('font-size', isMobile ? '11px' : '12px');
            yTitle.textContent = isWeekly ? 'Weekly Rank' : 'Cumulative Rank';
            svg.appendChild(yTitle);

            // Draw lines for each team (draw lines first, then logos on top)
            teams.forEach((team, index) => {
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');

                // Build path
                let d = '';
                team.data.forEach((point, i) => {
                    const x = xScale(point.week);
                    const y = yScale(point.rank);
                    d += i === 0 ? `M ${x} ${y}` : ` L ${x} ${y}`;
                });

                path.setAttribute('d', d);
                path.setAttribute('class', 'chart-line');
                path.setAttribute('stroke', colors[index]);
                path.setAttribute('stroke-width', isMobile ? '2' : '2.5');
                path.setAttribute('data-team-key', team.team_key);
                svg.appendChild(path);
            });

            // Add team logo markers at EVERY week for each team
            teams.forEach((team, teamIndex) => {
                team.data.forEach((point) => {
                    const x = xScale(point.week);
                    const y = yScale(point.rank);

                    // Create group for logo marker
                    const logoGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                    logoGroup.setAttribute('class', 'team-logo-marker');
                    logoGroup.setAttribute('data-team-key', team.team_key);
                    logoGroup.setAttribute('data-week', point.week);
                    // Store either weekly score or cumulative total
                    logoGroup.setAttribute('data-score', isWeekly ? point.score : point.cumulative);
                    logoGroup.setAttribute('data-is-weekly', isWeekly);
                    logoGroup.setAttribute('transform', `translate(${x}, ${y})`);

                    // Circle background
                    const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    circle.setAttribute('r', logoRadius);
                    circle.setAttribute('fill', 'white');
                    circle.setAttribute('stroke', colors[teamIndex]);
                    circle.setAttribute('stroke-width', isMobile ? '1.5' : '2');
                    logoGroup.appendChild(circle);

                    // Team logo image
                    if (team.logo) {
                        const imageOffset = logoImageSize / 2;
                        const image = document.createElementNS('http://www.w3.org/2000/svg', 'image');
                        image.setAttribute('href', team.logo);
                        image.setAttribute('x', -imageOffset);
                        image.setAttribute('y', -imageOffset);
                        image.setAttribute('width', logoImageSize);
                        image.setAttribute('height', logoImageSize);
                        image.setAttribute('style', `clip-path: circle(${imageOffset}px at center)`);
                        logoGroup.appendChild(image);
                    }

                    // Add hover/touch events
                    const scoreValue = isWeekly ? point.score : point.cumulative;
                    const handleInteraction = (e) => {
                        e.preventDefault();
                        handleTeamHover(team.team_key, team.team_name, scoreValue, point.week, point.rank, isWeekly, e.currentTarget);
                    };

                    logoGroup.addEventListener('mouseenter', handleInteraction);
                    logoGroup.addEventListener('touchstart', handleInteraction, { passive: false });
                    logoGroup.addEventListener('mouseleave', () => handleTeamHoverEnd());
                    logoGroup.addEventListener('touchend', () => setTimeout(handleTeamHoverEnd, 1500));

                    svg.appendChild(logoGroup);
                });
            });

            container.appendChild(svg);

            // Create tooltip element
            const tooltip = document.createElement('div');
            tooltip.className = 'chart-tooltip';
            tooltip.style.display = 'none';
            tooltip.id = 'chart-tooltip';
            container.appendChild(tooltip);

            // Add scroll hint for mobile
            if (isMobile && weeks.length > 10) {
                const scrollHint = document.createElement('div');
                scrollHint.style.cssText = 'text-align: center; color: #666; font-size: 0.8rem; margin-top: 0.5rem;';
                scrollHint.textContent = '← Scroll to see all weeks →';
                container.appendChild(scrollHint);
            }
        }

        function generateTeamColors(count) {
            const baseColors = [
                '#e6194b', '#3cb44b', '#ffe119', '#4363d8', '#f58231',
                '#911eb4', '#46f0f0', '#f032e6', '#bcf60c', '#fabebe',
                '#008080', '#e6beff', '#9a6324', '#fffac8', '#800000',
                '#aaffc3'
            ];

            const colors = [];
            for (let i = 0; i < count; i++) {
                colors.push(baseColors[i % baseColors.length]);
            }
            return colors;
        }

        function handleTeamHover(teamKey, teamName, score, week, rank, isWeekly, markerElement) {
            // Fade all lines and markers except the hovered team
            document.querySelectorAll('.chart-line').forEach(line => {
                if (line.getAttribute('data-team-key') === teamKey) {
                    line.classList.add('highlighted');
                    line.classList.remove('faded');
                } else {
                    line.classList.add('faded');
                    line.classList.remove('highlighted');
                }
            });

            document.querySelectorAll('.team-logo-marker').forEach(marker => {
                if (marker.getAttribute('data-team-key') === teamKey) {
                    marker.classList.add('highlighted');
                    marker.classList.remove('faded');
                } else {
                    marker.classList.add('faded');
                    marker.classList.remove('highlighted');
                }
            });

            // Show tooltip with appropriate label
            const tooltip = document.getElementById('chart-tooltip');

            if (tooltip && markerElement) {
                const containerRect = document.getElementById('season-chart').getBoundingClientRect();
                const markerRect = markerElement.getBoundingClientRect();

                const scoreLabel = isWeekly ? `Week ${week}: ${score.toLocaleString()} pts` : `Total: ${score.toLocaleString()} pts`;
                tooltip.innerHTML = `<strong>${teamName}</strong><br>${scoreLabel}<br>Rank: #${rank}`;
                tooltip.style.display = 'block';
                tooltip.style.left = (markerRect.left - containerRect.left + markerRect.width / 2) + 'px';
                tooltip.style.top = (markerRect.top - containerRect.top - 5) + 'px';
            }
        }

        function handleTeamHoverEnd() {
            // Remove all faded/highlighted classes
            document.querySelectorAll('.chart-line').forEach(line => {
                line.classList.remove('faded', 'highlighted');
            });

            document.querySelectorAll('.team-logo-marker').forEach(marker => {
                marker.classList.remove('faded', 'highlighted');
            });

            // Hide tooltip
            const tooltip = document.getElementById('chart-tooltip');
            if (tooltip) {
                tooltip.style.display = 'none';
            }
        }

        // ===== CALCULATE MANAGER AWARDS =====
        async function calculateManagerAwards() {
            const seasons = [2019, 2020, 2021, 2022, 2023, 2024, 2025];
            const seasonData = {};

            // Load all seasons data including player stats
            for (const year of seasons) {
                try {
                    let standingsResponse, playerStatsResponse;

                    if (year === 2025) {
                        standingsResponse = await fetch('data/current_season/standings.json');
                        playerStatsResponse = await fetch('data/current_season/player_stats.json');
                    } else {
                        standingsResponse = await fetch(`data/historical/${year}/final_standings.json`);
                        playerStatsResponse = await fetch(`data/historical/${year}/player_stats.json`);
                    }

                    if (standingsResponse.ok) {
                        const standings = await standingsResponse.json();
                        const normalizedStandings = normalizeStandingsData(standings, year);
                        const playerStats = playerStatsResponse.ok ? await playerStatsResponse.json() : [];
                        seasonData[year] = { standings: normalizedStandings, playerStats: playerStats };
                    }
                } catch (e) {
                    console.error(`Error loading ${year}:`, e);
                }
            }

            // Calculate awards by manager
            const managerAwards = {};

            for (const [year, data] of Object.entries(seasonData)) {
                const standings = data.standings;
                const playerStats = data.playerStats || [];

                // Find winners for each award category
                const mostWins = standings.reduce((max, team) =>
                    team.wins > max.wins ? team : max
                );
                const mostPoints = standings.reduce((max, team) =>
                    team.points_for > max.points_for ? team : max
                );
                const fewestWins = standings.reduce((min, team) =>
                    team.wins < min.wins ? team : min
                );
                const leastPoints = standings.reduce((min, team) =>
                    team.points_for < min.points_for ? team : min
                );
                const champion = standings.find(team => team.rank === 1);

                // Track awards
                if (champion) {
                    if (!managerAwards[champion.manager]) managerAwards[champion.manager] = {};
                    managerAwards[champion.manager].championships = (managerAwards[champion.manager].championships || 0) + 1;
                }

                if (!managerAwards[mostWins.manager]) managerAwards[mostWins.manager] = {};
                managerAwards[mostWins.manager].regularSeason = (managerAwards[mostWins.manager].regularSeason || 0) + 1;

                if (!managerAwards[mostPoints.manager]) managerAwards[mostPoints.manager] = {};
                managerAwards[mostPoints.manager].scoringChamp = (managerAwards[mostPoints.manager].scoringChamp || 0) + 1;

                if (!managerAwards[fewestWins.manager]) managerAwards[fewestWins.manager] = {};
                managerAwards[fewestWins.manager].garbage = (managerAwards[fewestWins.manager].garbage || 0) + 1;

                if (!managerAwards[leastPoints.manager]) managerAwards[leastPoints.manager] = {};
                managerAwards[leastPoints.manager].clown = (managerAwards[leastPoints.manager].clown || 0) + 1;

                // Mike Trout Award (highest scoring hitter)
                const batters = playerStats.filter(p => p.position_type === 'B');
                if (batters.length > 0) {
                    const topHitter = batters.reduce((max, player) =>
                        (player.fantasy_points || 0) > (max.fantasy_points || 0) ? player : max
                    );
                    // Find the team_key for this player's manager
                    const playerTeam = standings.find(t => t.team_name === topHitter.team_name);
                    const teamKey = playerTeam ? playerTeam.team_key : null;

                    // NORMALIZE THE MANAGER NAME with team info
                    const normalizedManager = normalizeManagerName(topHitter.manager, parseInt(year), topHitter.team_name, teamKey);
                    if (!managerAwards[normalizedManager]) managerAwards[normalizedManager] = {};
                    managerAwards[normalizedManager].troutAward = (managerAwards[normalizedManager].troutAward || 0) + 1;
                }

                // Jacob deGrom Award (highest scoring pitcher)
                const pitchers = playerStats.filter(p => p.position_type === 'P');
                if (pitchers.length > 0) {
                    const topPitcher = pitchers.reduce((max, player) =>
                        (player.fantasy_points || 0) > (max.fantasy_points || 0) ? player : max
                    );
                    // Find the team_key for this player's manager
                    const playerTeam = standings.find(t => t.team_name === topPitcher.team_name);
                    const teamKey = playerTeam ? playerTeam.team_key : null;

                    // NORMALIZE THE MANAGER NAME with team info
                    const normalizedManager = normalizeManagerName(topPitcher.manager, parseInt(year), topPitcher.team_name, teamKey);
                    if (!managerAwards[normalizedManager]) managerAwards[normalizedManager] = {};
                    managerAwards[normalizedManager].degromAward = (managerAwards[normalizedManager].degromAward || 0) + 1;
                }
            }

            return managerAwards;
        }

        // ===== LOAD MANAGER PROFILES =====
        async function loadManagerProfiles() {
            const loadingEl = document.getElementById('managers-loading');
            const errorEl = document.getElementById('managers-error');
            const gridEl = document.getElementById('manager-grid');

            try {
                loadingEl.style.display = 'block';
                errorEl.style.display = 'none';
                gridEl.innerHTML = '';

                // Load manager stats
                const response = await fetch('data/managers/all_time_stats.json');
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const rawManagersData = await response.json();

                // Load manager history for detailed view
                const historyResponse = await fetch('data/managers/manager_history.json');
                if (historyResponse.ok) {
                    managerHistoryData = await historyResponse.json();
                }

                // Normalize and merge manager data
                allManagersData = normalizeAndMergeManagerData(rawManagersData, managerHistoryData);

                // Determine all unique seasons we need to load
                const allSeasons = new Set();
                allManagersData.forEach(manager => {
                    manager.season_history.forEach(season => {
                        allSeasons.add(season.year);
                    });
                });

                // Pre-load team data for all seasons in parallel
                await Promise.all(Array.from(allSeasons).map(year => getTeamData(year)));

                // Calculate awards for all managers
                const managerAwards = await calculateManagerAwards();
                managerAwardsData = managerAwards; // Store globally for modal access

                // Now build manager logos using cached data
                const managerLogos = {};
                for (const manager of allManagersData) {
                    const recentSeason = Math.max(...manager.season_history.map(s => s.year));
                    const recentSeasonData = manager.season_history.find(s => s.year === recentSeason);

                    const teams = await getTeamData(recentSeason);
                    if (teams) {
                        const managerTeam = teams.find(t => t.team_name === recentSeasonData.team_name);
                        if (managerTeam) {
                            managerLogos[manager.manager_name] = managerTeam.team_logo;
                        }
                    }
                }

                // Determine which managers are currently active
                const currentStandingsResponse = await fetch('data/current_season/standings.json');
                let currentManagers = [];
                if (currentStandingsResponse.ok) {
                    const currentStandings = await currentStandingsResponse.json();
                    const normalizedStandings = normalizeStandingsData(currentStandings, 2025);
                    currentManagers = normalizedStandings.map(team => team.manager);
                }

                // Sort by win percentage (best first)
                allManagersData.sort((a, b) => b.win_pct - a.win_pct);

                allManagersData.forEach(manager => {
                    const isActive = currentManagers.includes(manager.manager_name);
                    const card = document.createElement('div');
                    card.className = isActive ? 'manager-card' : 'manager-card inactive';
                    card.onclick = () => showManagerDetail(manager.manager_name);

                    // Get last season played
                    const lastSeason = Math.max(...manager.season_history.map(s => s.year));

                    // Get logo if available
                    const logo = managerLogos[manager.manager_name] ? `<img src="${managerLogos[manager.manager_name]}" class="manager-logo" alt="${manager.manager_name}">` : '';

                    // Build awards display
                    const awards = managerAwards[manager.manager_name] || {};
                    let awardsHTML = '';

                    const awardsList = [];
                    if (awards.championships) awardsList.push({ type: 'image', src: 'champion_ring.png', count: awards.championships, alt: 'Championship' });
                    if (awards.regularSeason) awardsList.push({ type: 'emoji', emoji: '👑', count: awards.regularSeason });
                    if (awards.scoringChamp) awardsList.push({ type: 'emoji', emoji: '🏅', count: awards.scoringChamp });
                    if (awards.troutAward) awardsList.push({ type: 'image', src: 'attached_assets/trout_award_1764648146923.png', count: awards.troutAward, alt: 'Mike Trout Award' });
                    if (awards.degromAward) awardsList.push({ type: 'image', src: 'attached_assets/degom_award_1764648146918.png', count: awards.degromAward, alt: 'Jacob deGrom Award' });
                    if (awards.garbage) awardsList.push({ type: 'emoji', emoji: '🗑️', count: awards.garbage });
                    if (awards.clown) awardsList.push({ type: 'image', src: 'clown_award.png', count: awards.clown, alt: 'Clown Award' });

                    if (awardsList.length > 0) {
                        awardsHTML = '<div class="awards-row">';
                        awardsList.forEach(award => {
                            awardsHTML += '<div class="award-badge">';
                            if (award.type === 'image') {
                                awardsHTML += `<img src="${award.src}" alt="${award.alt}" class="award-image">`;
                            } else {
                                awardsHTML += award.emoji;
                            }
                            if (award.count > 1) {
                                awardsHTML += `<span class="award-count">x${award.count}</span>`;
                            }
                            awardsHTML += '</div>';
                        });
                        awardsHTML += '</div>';
                    }

                    card.innerHTML = `
                        <h3>${logo}${manager.manager_name}</h3>
                        <div style="display: flex; align-items: center; gap: 0.5rem; flex-wrap: wrap;">
                            ${!isActive ? '<div class="badge">Inactive</div>' : '<div class="badge">Active</div>'}
                            ${awardsHTML}
                        </div>
                        <div class="stat"><strong>Year Joined:</strong> ${manager.first_season}</div>
                        <div class="stat"><strong>Years in League:</strong> ${manager.seasons_played}</div>
                        ${!isActive ? `<div class="stat"><strong>Last Season:</strong> ${lastSeason}</div>` : ''}
                        <div class="stat"><strong>All-Time Record:</strong> ${manager.total_wins}-${manager.total_losses}-${manager.total_ties} (${(manager.win_pct * 100).toFixed(1)}%)</div>
                        <div class="stat"><strong>Championships:</strong> ${manager.championships}</div>
                        <div class="stat"><strong>Runner-ups:</strong> ${manager.runner_ups}</div>
                        <div class="stat"><strong>Playoff Apps:</strong> ${manager.playoff_appearances}</div>
                        <div class="stat"><strong>Avg Finish:</strong> ${manager.avg_finish.toFixed(1)}</div>
                    `;
                    gridEl.appendChild(card);
                });

                loadingEl.style.display = 'none';

                // Load and render win percentage chart
                await loadWinPctChart(allManagersData, managerLogos);

            } catch (error) {
                console.error('Error loading manager profiles:', error);
                loadingEl.style.display = 'none';
                errorEl.textContent = `Error loading manager profiles: ${error.message}`;
                errorEl.style.display = 'block';
            }
        }

        // ===== WIN PERCENTAGE OVER TIME CHART =====
        async function loadWinPctChart(managers, managerLogos) {
            const chartContainer = document.getElementById('winpct-chart-container');
            const chartEl = document.getElementById('winpct-chart');

            try {
                // Load all scores for all seasons
                const seasons = [2019, 2020, 2021, 2022, 2023, 2024, 2025];
                const allScoresData = [];
                const seasonStartWeeks = {}; // Track week index where each season starts

                let globalWeekIndex = 0;

                for (const year of seasons) {
                    try {
                        let response;
                        if (year === 2025) {
                            response = await fetch('data/current_season/all_scores.json');
                        } else {
                            response = await fetch(`data/historical/${year}/all_scores.json`);
                        }

                        if (response.ok) {
                            const scores = await response.json();
                            
                            // Load standings to map team_key to manager
                            let standingsResponse;
                            if (year === 2025) {
                                standingsResponse = await fetch('data/current_season/standings.json');
                            } else {
                                standingsResponse = await fetch(`data/historical/${year}/final_standings.json`);
                            }
                            
                            let standings = [];
                            if (standingsResponse.ok) {
                                standings = await standingsResponse.json();
                                standings = normalizeStandingsData(standings, year);
                            }

                            // Create team_key to manager mapping
                            const teamToManager = {};
                            standings.forEach(team => {
                                teamToManager[team.team_key] = team.manager;
                            });

                            // Get unique weeks in this season
                            const weeksInSeason = [...new Set(scores.map(s => s.week))].sort((a, b) => a - b);
                            
                            // Mark season start
                            seasonStartWeeks[year] = globalWeekIndex;

                            // Add scores with global week index
                            weeksInSeason.forEach((week, weekIdx) => {
                                const weekScores = scores.filter(s => s.week === week);
                                weekScores.forEach(score => {
                                    const manager = teamToManager[score.team_key];
                                    if (manager) {
                                        allScoresData.push({
                                            manager: manager,
                                            year: year,
                                            week: week,
                                            globalWeek: globalWeekIndex + weekIdx,
                                            score: score.team_score,
                                            opponentScore: score.opponent_score,
                                            isWin: score.team_score > score.opponent_score,
                                            isLoss: score.team_score < score.opponent_score
                                        });
                                    }
                                });
                            });

                            globalWeekIndex += weeksInSeason.length;
                        }
                    } catch (e) {
                        console.log(`Could not load ${year} scores for chart`);
                    }
                }

                if (allScoresData.length === 0) {
                    chartContainer.style.display = 'none';
                    return;
                }

                // Process data for chart
                const chartData = processWinPctData(allScoresData, managers, managerLogos, seasonStartWeeks);

                chartContainer.style.display = 'block';

                requestAnimationFrame(() => {
                    renderWinPctChart(chartEl, chartData);
                });

            } catch (error) {
                console.error('Error loading win pct chart:', error);
                chartContainer.style.display = 'none';
            }
        }

        function processWinPctData(scoresData, managers, managerLogos, seasonStartWeeks) {
            // Group scores by manager and calculate cumulative stats
            const managerData = {};

            // Sort by globalWeek
            scoresData.sort((a, b) => a.globalWeek - b.globalWeek);

            // Get all unique global weeks
            const allWeeks = [...new Set(scoresData.map(s => s.globalWeek))].sort((a, b) => a - b);
            
            // Build week labels (with year markers)
            const weekLabels = [];
            let currentYear = null;
            allWeeks.forEach(globalWeek => {
                const weekData = scoresData.find(s => s.globalWeek === globalWeek);
                if (weekData) {
                    if (weekData.year !== currentYear) {
                        currentYear = weekData.year;
                        weekLabels.push({ globalWeek, label: `${weekData.year}`, isSeasonStart: true, year: weekData.year, week: weekData.week });
                    } else {
                        weekLabels.push({ globalWeek, label: `W${weekData.week}`, isSeasonStart: false, year: weekData.year, week: weekData.week });
                    }
                }
            });

            // Process each score
            scoresData.forEach(score => {
                if (!managerData[score.manager]) {
                    managerData[score.manager] = {
                        manager: score.manager,
                        logo: managerLogos[score.manager] || '',
                        wins: 0,
                        losses: 0,
                        data: [],
                        lastGlobalWeek: 0
                    };
                }

                const md = managerData[score.manager];
                if (score.isWin) md.wins++;
                if (score.isLoss) md.losses++;

                // Calculate Net Wins (Distance from .500)
                // Win = +1, Loss = -1, Tie = 0
                const netWins = md.wins - md.losses;

                md.data.push({
                    globalWeek: score.globalWeek,
                    netWins: netWins, // CHANGED: Store net wins instead of win %
                    wins: md.wins,
                    losses: md.losses,
                    year: score.year,
                    week: score.week
                });

                md.lastGlobalWeek = Math.max(md.lastGlobalWeek, score.globalWeek);
            });

            // Convert to array and sort by final net wins
            const managerArray = Object.values(managerData);
            managerArray.sort((a, b) => {
                const aFinal = a.data.length > 0 ? a.data[a.data.length - 1].netWins : 0;
                const bFinal = b.data.length > 0 ? b.data[b.data.length - 1].netWins : 0;
                return bFinal - aFinal;
            });

            return {
                managers: managerArray,
                weeks: allWeeks,
                weekLabels: weekLabels,
                seasonStartWeeks: seasonStartWeeks,
                maxWeek: Math.max(...allWeeks)
            };
        }

        function renderWinPctChart(container, chartData) {
            container.innerHTML = '';
            
            // 1. Ensure container is positioned relative so tooltip works correctly
            container.style.position = 'relative';

            const { managers, weeks, weekLabels, seasonStartWeeks, maxWeek } = chartData;
            
            if (managers.length === 0 || weeks.length === 0) return;

            const isMobile = window.innerWidth <= 768;
            
            // Chart dimensions
            const containerWidth = container.clientWidth || 900;
            const minChartWidth = isMobile ? Math.max(weeks.length * 20, 600) : Math.max(weeks.length * 12, 800);
            
            const margin = { top: 40, right: 80, bottom: 80, left: 60 };
            const width = Math.max(minChartWidth, containerWidth - margin.left - margin.right);
            const height = 450;

            const minWeek = Math.min(...weeks);

            // Determine Y-axis domain (Min/Max Net Wins)
            let maxNet = 0;
            let minNet = 0;
            
            managers.forEach(m => {
                m.data.forEach(d => {
                    if (d.netWins > maxNet) maxNet = d.netWins;
                    if (d.netWins < minNet) minNet = d.netWins;
                });
            });

            // Add padding to Y axis
            maxNet = Math.ceil(Math.max(maxNet, 5) / 5) * 5 + 5;
            minNet = Math.floor(Math.min(minNet, -5) / 5) * 5 - 5;
            const yRange = maxNet - minNet;

            // Scale functions
            const xScale = (globalWeek) => margin.left + ((globalWeek - minWeek) / (maxWeek - minWeek || 1)) * width;
            const yScale = (val) => margin.top + ((maxNet - val) / yRange) * (height - margin.top - margin.bottom);

            // Generate colors
            const colors = generateTeamColors(managers.length);
            const managerColorMap = {};
            managers.forEach((m, i) => {
                managerColorMap[m.manager] = colors[i];
            });

            // Create SVG
            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.setAttribute('width', width + margin.left + margin.right);
            svg.setAttribute('height', height);
            svg.setAttribute('class', 'chart-svg winpct-chart');
            svg.style.display = 'block';

            // --- LAYERS SETUP ---
            // 1. Grid Lines Layer (bottom)
            const gridLayer = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            svg.appendChild(gridLayer);

            // 2. Data/Chart Layer (middle)
            const chartLayer = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            svg.appendChild(chartLayer);

            // 3. Y-Axis Layer (top - sticky)
            const yAxisGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            yAxisGroup.setAttribute('class', 'y-axis-group');
            // Add a white background rect to the Y-axis group to obscure lines behind it when scrolling
            const yAxisBg = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            yAxisBg.setAttribute('x', 0);
            yAxisBg.setAttribute('y', 0);
            yAxisBg.setAttribute('width', margin.left);
            yAxisBg.setAttribute('height', height);
            yAxisBg.setAttribute('fill', 'white');
            yAxisGroup.appendChild(yAxisBg);
            
            // Add a vertical divider line at the edge of the Y-axis
            const yAxisLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            yAxisLine.setAttribute('x1', margin.left);
            yAxisLine.setAttribute('y1', margin.top);
            yAxisLine.setAttribute('x2', margin.left);
            yAxisLine.setAttribute('y2', height - margin.bottom);
            yAxisLine.setAttribute('stroke', '#ccc');
            yAxisLine.setAttribute('stroke-width', '1');
            yAxisGroup.appendChild(yAxisLine);

            svg.appendChild(yAxisGroup);

            // --- SCROLL HANDLER FOR STICKY AXIS ---
            container.addEventListener('scroll', () => {
                yAxisGroup.setAttribute('transform', `translate(${container.scrollLeft}, 0)`);
            });

            // Click background to deselect
            svg.addEventListener('click', (e) => {
                if(e.target === svg) {
                    selectedManager = null;
                    resetHighlights();
                }
            });

            // Draw horizontal grid lines (on Grid Layer) and Labels (on Y-Axis Layer)
            for (let val = minNet; val <= maxNet; val += 5) {
                const y = yScale(val);
                
                // Grid Line
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', margin.left);
                line.setAttribute('y1', y);
                line.setAttribute('x2', margin.left + width);
                line.setAttribute('y2', y);
                
                if (val === 0) {
                    line.setAttribute('stroke', '#000');
                    line.setAttribute('stroke-width', '2');
                } else {
                    line.setAttribute('stroke', '#e0e0e0');
                    line.setAttribute('stroke-width', '1');
                    line.setAttribute('stroke-dasharray', '3,3');
                }
                gridLayer.appendChild(line);

                // Axis Label (Sticky)
                const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                label.setAttribute('x', margin.left - 10);
                label.setAttribute('y', y + 4);
                label.setAttribute('text-anchor', 'end');
                label.setAttribute('font-size', '11px');
                label.setAttribute('fill', val === 0 ? '#000' : '#666');
                label.setAttribute('font-weight', val === 0 ? 'bold' : 'normal');
                const labelText = val > 0 ? `+${val}` : `${val}`;
                label.textContent = labelText;
                yAxisGroup.appendChild(label); // Append to sticky group
            }

            // Draw Y-axis title (Sticky)
            const yTitle = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            yTitle.setAttribute('x', 15);
            yTitle.setAttribute('y', height / 2);
            yTitle.setAttribute('text-anchor', 'middle');
            yTitle.setAttribute('font-size', '12px');
            yTitle.setAttribute('fill', '#666');
            yTitle.setAttribute('transform', `rotate(-90, 15, ${height / 2})`);
            yTitle.textContent = 'Games Above .500';
            yAxisGroup.appendChild(yTitle); // Append to sticky group

            // Draw vertical season separator lines
            Object.entries(seasonStartWeeks).forEach(([year, startWeek]) => {
                if (startWeek > minWeek) {
                    const x = xScale(startWeek);
                    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    line.setAttribute('x1', x);
                    line.setAttribute('y1', margin.top);
                    line.setAttribute('x2', x);
                    line.setAttribute('y2', height - margin.bottom);
                    line.setAttribute('stroke', '#1e3c72');
                    line.setAttribute('stroke-width', '2');
                    line.setAttribute('stroke-dasharray', '5,3');
                    gridLayer.appendChild(line);
                }
            });

            // Draw X-axis labels
            weekLabels.forEach((wl, idx) => {
                const showLabel = wl.isSeasonStart || idx % (isMobile ? 8 : 4) === 0;
                if (!showLabel && !wl.isSeasonStart) return;

                const x = xScale(wl.globalWeek);
                const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                label.setAttribute('x', x);
                label.setAttribute('y', height - margin.bottom + 15);
                label.setAttribute('text-anchor', 'start');
                label.setAttribute('font-size', wl.isSeasonStart ? '12px' : '10px');
                label.setAttribute('font-weight', wl.isSeasonStart ? 'bold' : 'normal');
                label.setAttribute('fill', wl.isSeasonStart ? '#1e3c72' : '#666');
                label.setAttribute('transform', `rotate(45, ${x}, ${height - margin.bottom + 15})`);
                label.textContent = wl.isSeasonStart ? wl.year : wl.label;
                gridLayer.appendChild(label); // X-axis moves with scroll, so put on gridLayer
            });

            // Create tooltip
            const tooltip = document.createElement('div');
            tooltip.className = 'chart-tooltip';
            tooltip.style.display = 'none';
            container.appendChild(tooltip);

            // --- STATE MANAGEMENT ---
            let selectedManager = null; // Track locked line

            // Helper to apply visual styles
            const applyHighlight = (managerName) => {
                document.querySelectorAll('.winpct-chart .chart-line').forEach(line => {
                    if (line.getAttribute('data-manager') === managerName) {
                        line.classList.add('highlighted');
                        line.classList.remove('faded');
                        // Move to end of chartLayer to be on top of others
                        if (line.parentNode === chartLayer) {
                            chartLayer.appendChild(line);
                        }
                    } else {
                        line.classList.add('faded');
                        line.classList.remove('highlighted');
                    }
                });
            };

            const resetHighlights = () => {
                document.querySelectorAll('.winpct-chart .chart-line').forEach(line => {
                    line.classList.remove('highlighted', 'faded');
                });
            };

            // Draw lines for each manager
            const lineGroups = [];
            
            managers.forEach((manager, idx) => {
                if (manager.data.length < 2) return;

                const color = managerColorMap[manager.manager];
                const group = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                group.setAttribute('class', 'chart-line');
                group.setAttribute('data-manager', manager.manager);

                // Build path
                let pathD = '';
                manager.data.forEach((point, i) => {
                    const x = xScale(point.globalWeek);
                    const y = yScale(point.netWins);
                    pathD += (i === 0 ? 'M' : 'L') + `${x},${y} `;
                });

                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                path.setAttribute('d', pathD.trim());
                path.setAttribute('fill', 'none');
                path.setAttribute('stroke', color);
                path.setAttribute('stroke-width', '2.5');
                path.setAttribute('stroke-linejoin', 'round');
                path.setAttribute('stroke-linecap', 'round');
                group.appendChild(path);

                // Invisible wider path for hover detection
                const hoverPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                hoverPath.setAttribute('d', pathD.trim());
                hoverPath.setAttribute('fill', 'none');
                hoverPath.setAttribute('stroke', 'transparent');
                hoverPath.setAttribute('stroke-width', '15');
                hoverPath.style.cursor = 'pointer';
                group.appendChild(hoverPath);

                // Logo/End marker
                const lastPoint = manager.data[manager.data.length - 1];
                const logoX = xScale(lastPoint.globalWeek);
                const logoY = yScale(lastPoint.netWins);
                const logoRadius = 14;

                if (manager.logo) {
                    const clipId = `winpct-clip-${idx}`;
                    const clipPath = document.createElementNS('http://www.w3.org/2000/svg', 'clipPath');
                    clipPath.setAttribute('id', clipId);
                    const clipCircle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    clipCircle.setAttribute('cx', logoX);
                    clipCircle.setAttribute('cy', logoY);
                    clipCircle.setAttribute('r', logoRadius);
                    clipPath.appendChild(clipCircle);
                    svg.appendChild(clipPath); // Defines must be in SVG, usually ok anywhere

                    const bgCircle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    bgCircle.setAttribute('cx', logoX);
                    bgCircle.setAttribute('cy', logoY);
                    bgCircle.setAttribute('r', logoRadius + 2);
                    bgCircle.setAttribute('fill', 'white');
                    bgCircle.setAttribute('stroke', color);
                    bgCircle.setAttribute('stroke-width', '2');
                    group.appendChild(bgCircle);

                    const logoImg = document.createElementNS('http://www.w3.org/2000/svg', 'image');
                    logoImg.setAttribute('x', logoX - logoRadius);
                    logoImg.setAttribute('y', logoY - logoRadius);
                    logoImg.setAttribute('width', logoRadius * 2);
                    logoImg.setAttribute('height', logoRadius * 2);
                    logoImg.setAttribute('href', manager.logo);
                    logoImg.setAttribute('clip-path', `url(#${clipId})`);
                    logoImg.setAttribute('preserveAspectRatio', 'xMidYMid slice');
                    group.appendChild(logoImg);
                } else {
                    const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    circle.setAttribute('cx', logoX);
                    circle.setAttribute('cy', logoY);
                    circle.setAttribute('r', logoRadius);
                    circle.setAttribute('fill', color);
                    circle.setAttribute('stroke', 'white');
                    circle.setAttribute('stroke-width', '2');
                    group.appendChild(circle);

                    const initial = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    initial.setAttribute('x', logoX);
                    initial.setAttribute('y', logoY + 5);
                    initial.setAttribute('text-anchor', 'middle');
                    initial.setAttribute('fill', 'white');
                    initial.setAttribute('font-size', '12px');
                    initial.setAttribute('font-weight', 'bold');
                    initial.textContent = manager.manager.charAt(0);
                    group.appendChild(initial);
                }

                const finalNetWins = lastPoint.netWins;
                
                // --- EVENTS ---

                // Click to toggle Highlight
                group.addEventListener('click', (e) => {
                    e.stopPropagation(); // Prevent SVG background click
                    if (selectedManager === manager.manager) {
                        // Deselect if clicking the same one
                        selectedManager = null;
                        resetHighlights();
                    } else {
                        // Select new one
                        selectedManager = manager.manager;
                        applyHighlight(manager.manager);
                    }
                });

                // Hover Effects
                group.addEventListener('mouseenter', (e) => {
                    // Always highlight on hover, even if something else is selected (transient view)
                    applyHighlight(manager.manager);

                    // Show tooltip with Logo
                    const sign = finalNetWins > 0 ? '+' : '';
                    
                    // Construct Logo HTML
                    const logoHtml = manager.logo ? 
                        `<img src="${manager.logo}" style="width: 40px; height: 40px; border-radius: 50%; object-fit: cover; border: 2px solid ${color};">` :
                        `<div style="width: 40px; height: 40px; border-radius: 50%; background: ${color}; color: white; display: flex; align-items: center; justify-content: center; font-weight: bold; font-size: 18px; border: 2px solid white;">${manager.manager.charAt(0)}</div>`;

                    tooltip.innerHTML = `
                        <div style="display: flex; align-items: center; gap: 12px;">
                            ${logoHtml}
                            <div>
                                <div style="font-weight: bold; font-size: 1.1em;">${manager.manager}</div>
                                <div style="margin-top: 2px; color: #ccc;">Record: ${manager.wins}-${manager.losses}</div>
                                <div style="margin-top: 2px; color: ${finalNetWins >= 0 ? '#4cd137' : '#ff4757'}; font-weight: bold;">
                                    ${sign}${finalNetWins} games
                                </div>
                            </div>
                        </div>
                    `;
                    tooltip.style.display = 'block';
                });

                // Tooltip follow mouse (FIXED for scrolling)
                group.addEventListener('mousemove', (e) => {
                    const rect = container.getBoundingClientRect();
                    const scrollLeft = container.scrollLeft;
                    
                    tooltip.style.left = (e.clientX - rect.left + scrollLeft + 15) + 'px';
                    tooltip.style.top = (e.clientY - rect.top - 10) + 'px';
                });

                // Mouse Leave
                group.addEventListener('mouseleave', () => {
                    tooltip.style.display = 'none';
                    
                    // If a manager is selected, revert to highlighting them
                    if (selectedManager) {
                        applyHighlight(selectedManager);
                    } else {
                        // Otherwise reset to all visible
                        resetHighlights();
                    }
                });

                lineGroups.push(group);
            });

            // Add lines to Chart Layer
            lineGroups.reverse().forEach(g => chartLayer.appendChild(g));

            container.appendChild(svg);
        }

        // ===== SHOW MANAGER DETAIL MODAL =====
        async function showManagerDetail(managerName) {
            const manager = allManagersData.find(m => m.manager_name === managerName);
            if (!manager) return;

            const modal = document.getElementById('manager-modal');
            const modalBody = document.getElementById('modal-body');

            // Load team logos for each season using cached data
            const seasonLogos = {};
            for (const season of manager.season_history) {
                const teams = await getTeamData(season.year);
                if (teams) {
                    const managerTeam = teams.find(t => t.team_name === season.team_name);
                    if (managerTeam) {
                        seasonLogos[season.year] = managerTeam.team_logo;
                    }
                }
            }

            // Build season timeline
            const seasonHistory = manager.season_history.sort((a, b) => b.year - a.year);
            let timelineHTML = seasonHistory.map(season => {
                let rankClass = '';
                let rankText = `#${season.rank}`;

                if (season.rank === 1) {
                    rankClass = 'champion';
                    rankText = '🏆 Champion';
                } else if (season.rank === 2) {
                    rankClass = 'runner-up';
                    rankText = '🥈 Runner-up';
                }

                const logo = seasonLogos[season.year] ? `<img src="${seasonLogos[season.year]}" class="timeline-logo" alt="${season.team_name}">` : '';

                return `
                    <div class="timeline-item">
                        <div class="year">${season.year}</div>
                        <div class="details">
                            <span class="rank ${rankClass}">${rankText}</span>
                            <span>${season.wins}-${season.losses} | ${season.points_for.toLocaleString()} pts</span>
                            <div style="margin-top: 0.25rem; color: #666; font-size: 0.9rem;">
                                Team: ${season.team_name}
                            </div>
                        </div>
                        ${logo}
                    </div>
                `;
            }).join('');

            // Calculate head-to-head records
            const h2hRecords = await calculateHeadToHeadRecords(managerName);
            let h2hHTML = '';

            if (h2hRecords.length > 0) {
                h2hHTML = `
                    <div class="timeline">
                        <h3>Head-to-Head Records</h3>
                        <table class="matchup-table" id="h2h-table">
                            <thead>
                                <tr>
                                    <th class="sortable" onclick="sortH2HTable(0, 'string')">Opponent</th>
                                    <th class="sortable" onclick="sortH2HTable(1, 'record')">Record</th>
                                    <th class="sortable" onclick="sortH2HTable(2, 'number')">Win %</th>
                                    <th class="sortable" onclick="sortH2HTable(3, 'number')">Avg Points For</th>
                                    <th class="sortable" onclick="sortH2HTable(4, 'number')">Avg Points Against</th>
                                </tr>
                            </thead>
                            <tbody id="h2h-body">
                                ${h2hRecords.map(record => `
                                    <tr>
                                        <td>${record.opponent}</td>
                                        <td>${record.wins}-${record.losses}</td>
                                        <td>${(record.win_pct * 100).toFixed(1)}%</td>
                                        <td>${record.avg_points_for.toFixed(1)}</td>
                                        <td>${record.avg_points_against.toFixed(1)}</td>
                                    </tr>
                                `).join('')}
                            </tbody>
                        </table>
                    </div>
                `;
            }

            modalBody.innerHTML = `
                <div class="modal-stats">
                    <div class="stat-box">
                        <div class="value">${manager.total_wins}-${manager.total_losses}-${manager.total_ties}</div>
                        <div class="label">All-Time Record</div>
                    </div>
                    <div class="stat-box">
                        <div class="value">${(manager.win_pct * 100).toFixed(1)}%</div>
                        <div class="label">Win Percentage</div>
                    </div>
                    <div class="stat-box">
                        <div class="value">${manager.championships}</div>
                        <div class="label">Championships</div>
                    </div>
                    <div class="stat-box">
                        <div class="value">${manager.avg_finish.toFixed(1)}</div>
                        <div class="label">Avg Finish</div>
                    </div>
                    <div class="stat-box">
                        <div class="value">${manager.playoff_appearances}</div>
                        <div class="label">Playoff Apps</div>
                    </div>
                    <div class="stat-box">
                        <div class="value">${manager.total_points_for.toLocaleString()}</div>
                        <div class="label">Career Points</div>
                    </div>
                </div>
                
                <div class="timeline">
                    <h3>Season-by-Season Timeline</h3>
                    ${timelineHTML}
                </div>
                
                ${h2hHTML}
            `;

            // Set the header separately with awards emojis
            const modalHeaderSection = document.getElementById('modal-header-section');

            // Build awards display for modal header (same format as cards)
            const awards = managerAwardsData[manager.manager_name] || {};
            let modalAwardsHTML = '';

            const awardsList = [];
            if (awards.championships) awardsList.push({ type: 'image', src: 'champion_ring.png', count: awards.championships, alt: 'Championship' });
            if (awards.regularSeason) awardsList.push({ type: 'emoji', emoji: '👑', count: awards.regularSeason });
            if (awards.scoringChamp) awardsList.push({ type: 'emoji', emoji: '🏅', count: awards.scoringChamp });
            if (awards.troutAward) awardsList.push({ type: 'image', src: 'attached_assets/trout_award_1764648146923.png', count: awards.troutAward, alt: 'Mike Trout Award' });
            if (awards.degromAward) awardsList.push({ type: 'image', src: 'attached_assets/degom_award_1764648146918.png', count: awards.degromAward, alt: 'Jacob deGrom Award' });
            if (awards.garbage) awardsList.push({ type: 'emoji', emoji: '🗑️', count: awards.garbage });
            if (awards.clown) awardsList.push({ type: 'image', src: 'clown_award.png', count: awards.clown, alt: 'Clown Award' });

            if (awardsList.length > 0) {
                modalAwardsHTML = '<div class="awards-row">';
                awardsList.forEach(award => {
                    modalAwardsHTML += '<div class="award-badge">';
                    if (award.type === 'image') {
                        modalAwardsHTML += `<img src="${award.src}" alt="${award.alt}" class="award-image">`;
                    } else {
                        modalAwardsHTML += award.emoji;
                    }
                    if (award.count > 1) {
                        modalAwardsHTML += `<span class="award-count">x${award.count}</span>`;
                    }
                    modalAwardsHTML += '</div>';
                });
                modalAwardsHTML += '</div>';
            }

            modalHeaderSection.innerHTML = `
                <div class="modal-header">
                    <div style="display: flex; align-items: center; gap: 0.75rem; flex-wrap: wrap;">
                        <h2 style="margin: 0;">${manager.manager_name}</h2>
                        ${modalAwardsHTML}
                    </div>
                    <p style="color: #666; margin-top: 0.5rem;">Joined ${manager.first_season} | ${manager.seasons_played} seasons</p>
                </div>
            `;

            // Store h2h data for sorting
            window.currentH2HData = h2hRecords;
            window.currentSortColumn = null;
            window.currentSortDirection = 'desc';

            modal.classList.add('active');
        }

        // ===== SORT HEAD-TO-HEAD TABLE =====
        function sortH2HTable(columnIndex, dataType) {
            const tbody = document.getElementById('h2h-body');
            const headers = document.querySelectorAll('#h2h-table th');

            if (!window.currentH2HData || window.currentH2HData.length === 0) return;

            // Toggle sort direction if clicking same column
            if (window.currentSortColumn === columnIndex) {
                window.currentSortDirection = window.currentSortDirection === 'asc' ? 'desc' : 'asc';
            } else {
                window.currentSortColumn = columnIndex;
                window.currentSortDirection = 'desc'; // Default to descending
            }

            // Update header classes
            headers.forEach((header, index) => {
                header.classList.remove('sorted-asc', 'sorted-desc');
                if (index === columnIndex) {
                    header.classList.add(window.currentSortDirection === 'asc' ? 'sorted-asc' : 'sorted-desc');
                }
            });

            // Sort the data
            const sortedData = [...window.currentH2HData].sort((a, b) => {
                let valueA, valueB;

                switch (columnIndex) {
                    case 0: // Opponent
                        valueA = a.opponent.toLowerCase();
                        valueB = b.opponent.toLowerCase();
                        break;
                    case 1: // Record (by total wins)
                        valueA = a.wins;
                        valueB = b.wins;
                        break;
                    case 2: // Win %
                        valueA = a.win_pct;
                        valueB = b.win_pct;
                        break;
                    case 3: // Avg Points For
                        valueA = a.avg_points_for;
                        valueB = b.avg_points_for;
                        break;
                    case 4: // Avg Points Against
                        valueA = a.avg_points_against;
                        valueB = b.avg_points_against;
                        break;
                }

                if (window.currentSortDirection === 'asc') {
                    return valueA > valueB ? 1 : valueA < valueB ? -1 : 0;
                } else {
                    return valueA < valueB ? 1 : valueA > valueB ? -1 : 0;
                }
            });

            // Update table
            tbody.innerHTML = sortedData.map(record => `
                <tr>
                    <td>${record.opponent}</td>
                    <td>${record.wins}-${record.losses}</td>
                    <td>${(record.win_pct * 100).toFixed(1)}%</td>
                    <td>${record.avg_points_for.toFixed(1)}</td>
                    <td>${record.avg_points_against.toFixed(1)}</td>
                </tr>
            `).join('');
        }

        // ===== CALCULATE HEAD-TO-HEAD RECORDS =====
        async function calculateHeadToHeadRecords(managerName) {
            try {
                // Get all available seasons and load their scores
                const h2hMap = {};

                const manager = allManagersData.find(m => m.manager_name === managerName);
                if (!manager) return [];

                for (const season of manager.season_history.map(h => h.year)) {
                    try {
                        let scoresResponse;
                        if (season === 2025) {
                            scoresResponse = await fetch('data/current_season/all_scores.json');
                        } else {
                            scoresResponse = await fetch(`data/historical/${season}/all_scores.json`);
                        }

                        if (!scoresResponse.ok) continue;

                        const scores = await scoresResponse.json();
                        let standings = season === 2025
                            ? await (await fetch('data/current_season/standings.json')).json()
                            : await (await fetch(`data/historical/${season}/final_standings.json`)).json();

                        // Normalize standings
                        standings = normalizeStandingsData(standings, season);

                        // Create team_key to manager mapping
                        const teamToManager = {};
                        standings.forEach(team => {
                            teamToManager[team.team_key] = team.manager;
                        });

                        // Find manager's team key
                        const managerTeam = standings.find(team => team.manager === managerName);
                        if (!managerTeam) continue;

                        // Process matchups
                        scores.forEach(matchup => {
                            if (matchup.team_key === managerTeam.team_key) {
                                const opponent = teamToManager[matchup.opponent_key];
                                if (!opponent) return;

                                if (!h2hMap[opponent]) {
                                    h2hMap[opponent] = {
                                        opponent: opponent,
                                        wins: 0,
                                        losses: 0,
                                        total_points_for: 0,
                                        total_points_against: 0,
                                        games: 0
                                    };
                                }

                                h2hMap[opponent].games++;
                                h2hMap[opponent].total_points_for += matchup.team_score;
                                h2hMap[opponent].total_points_against += matchup.opponent_score;

                                if (matchup.team_score > matchup.opponent_score) {
                                    h2hMap[opponent].wins++;
                                } else if (matchup.team_score < matchup.opponent_score) {
                                    h2hMap[opponent].losses++;
                                }
                            }
                        });
                    } catch (e) {
                        console.log(`Could not load scores for ${season}`);
                    }
                }

                // Convert to array and calculate averages
                const h2hRecords = Object.values(h2hMap).map(record => ({
                    ...record,
                    win_pct: record.wins / (record.wins + record.losses),
                    avg_points_for: record.total_points_for / record.games,
                    avg_points_against: record.total_points_against / record.games
                }));

                // Sort by win percentage
                h2hRecords.sort((a, b) => b.win_pct - a.win_pct);

                return h2hRecords;
            } catch (error) {
                console.error('Error calculating head-to-head:', error);
                return [];
            }
        }

        // ===== CLOSE MANAGER MODAL =====
        function closeManagerModal() {
            const modal = document.getElementById('manager-modal');
            modal.classList.remove('active');
        }

        // Close modal when clicking outside
        window.onclick = function (event) {
            const modal = document.getElementById('manager-modal');
            if (event.target === modal) {
                closeManagerModal();
            }
        }

        // ===== NAVIGATION =====
        function showSection(sectionId) {
            // Hide all sections
            document.querySelectorAll('.section').forEach(section => {
                section.classList.remove('active');
            });

            // Remove active class from all desktop nav buttons
            document.querySelectorAll('.nav-btn').forEach(btn => {
                btn.classList.remove('active');
            });

            // Remove active class from all mobile nav buttons
            document.querySelectorAll('.mobile-nav-btn').forEach(btn => {
                btn.classList.remove('active');
            });

            // Show selected section
            document.getElementById(sectionId).classList.add('active');

            // Add active class to clicked button (both desktop and mobile)
            if (event && event.target) {
                event.target.closest('button')?.classList.add('active');
            }

            // Also update the corresponding nav buttons by section ID
            const sectionToIndex = {
                'standings': 0,
                'awards': 1,
                'champions': 2,
                'scoring': 3,
                'managers': 4
            };
            const index = sectionToIndex[sectionId];
            if (index !== undefined) {
                document.querySelectorAll('.nav-btn')[index]?.classList.add('active');
                document.querySelectorAll('.mobile-nav-btn')[index]?.classList.add('active');
            }

            // Load section-specific data
            if (sectionId === 'awards') {
                loadAwards();
            } else if (sectionId === 'champions') {
                loadChampionData();
            } else if (sectionId === 'scoring') {
                // Load player scoring if not already loaded
                if (allPlayersData.length === 0) {
                    loadPlayerScoring();
                }
            }
        }

        // ===== HALL OF CHAMPIONS =====
        let championsDataLoaded = false;
        let allChampionsData = {};

        async function loadChampionData() {
            const loadingEl = document.getElementById('champions-loading');
            const errorEl = document.getElementById('champions-error');
            const contentEl = document.getElementById('champions-content');
            const seasonSelect = document.getElementById('champions-season');

            try {
                loadingEl.style.display = 'block';
                errorEl.style.display = 'none';
                contentEl.style.display = 'none';

                // Populate season dropdown if not already done
                if (seasonSelect.options.length === 0) {
                    const seasons = [2025, 2024, 2023, 2022, 2021, 2020, 2019];
                    seasons.forEach(year => {
                        const option = document.createElement('option');
                        option.value = year;
                        option.textContent = year === 2025 ? '2025 (Current)' : year;
                        seasonSelect.appendChild(option);
                    });
                }

                const selectedYear = parseInt(seasonSelect.value) || 2025;
                const isCurrentSeason = selectedYear === 2025;
                const dataPath = isCurrentSeason ? 'data/current_season' : `data/historical/${selectedYear}`;

                // Load standings to find champion
                const standingsFile = isCurrentSeason ? 'standings.json' : 'final_standings.json';
                const standingsResponse = await fetch(`${dataPath}/${standingsFile}`);
                if (!standingsResponse.ok) throw new Error(`No data for ${selectedYear}`);
                let standings = await standingsResponse.json();
                standings = normalizeStandingsData(standings, selectedYear);

                // Find champion (rank 1)
                const champion = standings.find(team => team.rank === 1);
                if (!champion) throw new Error('Champion not found');

                // Load teams data for logo
                const teamsResponse = await fetch(`${dataPath}/teams.json`);
                let teams = [];
                if (teamsResponse.ok) {
                    teams = await teamsResponse.json();
                }
                const championTeam = teams.find(t => t.team_key === champion.team_key);
                const teamLogo = championTeam?.team_logo || '';

                // Load scores for schedule
                const scoresResponse = await fetch(`${dataPath}/all_scores.json`);
                let scores = [];
                if (scoresResponse.ok) {
                    scores = await scoresResponse.json();
                }

                // Load player stats for roster
                const playerStatsResponse = await fetch(`${dataPath}/player_stats.json`);
                let playerStats = [];
                if (playerStatsResponse.ok) {
                    playerStats = await playerStatsResponse.json();
                }

                // Count championships for this manager (and check for back-to-back)
                const championshipInfo = await countManagerChampionships(champion.manager, selectedYear);

                // Render champion header
                renderChampionHeader(champion, teamLogo, selectedYear, isCurrentSeason);

                // Render championship count
                renderChampionshipCount(championshipInfo);

                // Render stats
                renderChampionStats(champion, scores, standings);

                // Render schedule
                renderChampionSchedule(champion, scores, standings, teams);

                // Render roster
                renderChampionRoster(champion, playerStats);

                loadingEl.style.display = 'none';
                contentEl.style.display = 'block';

            } catch (error) {
                console.error('Error loading champion data:', error);
                loadingEl.style.display = 'none';
                errorEl.textContent = `Error: ${error.message}`;
                errorEl.style.display = 'block';
            }
        }

        async function countManagerChampionships(managerName, upToYear) {
            const seasons = [2019, 2020, 2021, 2022, 2023, 2024, 2025];
            let count = 0;
            let thisIsNth = 0;
            let championshipYears = [];

            for (const year of seasons) {
                if (year > upToYear) break;
                try {
                    let response;
                    if (year === 2025) {
                        response = await fetch('data/current_season/standings.json');
                    } else {
                        response = await fetch(`data/historical/${year}/final_standings.json`);
                    }
                    if (response.ok) {
                        let standings = await response.json();
                        standings = normalizeStandingsData(standings, year);
                        const champ = standings.find(t => t.rank === 1);
                        if (champ && champ.manager === managerName) {
                            count++;
                            championshipYears.push(year);
                            if (year === upToYear) {
                                thisIsNth = count;
                            }
                        }
                    }
                } catch (e) {
                    console.log(`Could not load ${year} standings`);
                }
            }

            // Check for back-to-back (consecutive years)
            let isBackToBack = false;
            let consecutiveCount = 1;
            
            if (championshipYears.length >= 2) {
                const currentIndex = championshipYears.indexOf(upToYear);
                if (currentIndex > 0) {
                    // Check if previous championship was the year before
                    const prevYear = championshipYears[currentIndex - 1];
                    if (prevYear === upToYear - 1) {
                        isBackToBack = true;
                        // Count consecutive championships
                        consecutiveCount = 2;
                        for (let i = currentIndex - 2; i >= 0; i--) {
                            if (championshipYears[i] === championshipYears[i + 1] - 1) {
                                consecutiveCount++;
                            } else {
                                break;
                            }
                        }
                    }
                }
            }

            return {
                nth: thisIsNth,
                total: count,
                isBackToBack: isBackToBack,
                consecutiveCount: consecutiveCount,
                years: championshipYears
            };
        }

        function getOrdinal(n) {
            const s = ["th", "st", "nd", "rd"];
            const v = n % 100;
            return n + (s[(v - 20) % 10] || s[v] || s[0]);
        }

        function renderChampionHeader(champion, teamLogo, year, isCurrentSeason) {
            const headerEl = document.getElementById('champion-header');
            const placeholderLogo = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIj48cmVjdCB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCIgZmlsbD0iIzFhMWEyZSIvPjx0ZXh0IHg9IjUwIiB5PSI1NSIgZm9udC1zaXplPSI0MCIgdGV4dC1hbmNob3I9Im1pZGRsZSIgZmlsbD0iI2ZmZCI+8J+Phjwv dGV4dD48L3N2Zz4=';
            
            const seasonLabel = isCurrentSeason ? `${year} Season Leader` : `${year} Season Champion`;

            headerEl.innerHTML = `
                <img src="${teamLogo || placeholderLogo}" alt="${champion.team_name}" class="team-logo" onerror="this.src='${placeholderLogo}'">
                <div class="champion-info">
                    <h3>${champion.team_name}</h3>
                    <div class="manager-name">Manager: ${champion.manager}</div>
                    <div class="season-year">${seasonLabel}</div>
                </div>
                <div class="trophy-icon">🏆</div>
            `;
        }

        function renderChampionshipCount(info) {
            const bannerEl = document.getElementById('championship-count-banner');
            
            if (!info || info.nth === 0) {
                bannerEl.style.display = 'none';
                return;
            }
            
            const { nth, isBackToBack, consecutiveCount } = info;
            const ordinal = getOrdinal(nth);
            let message = '';
            
            if (nth === 1) {
                message = `🌟 First Championship Title! 🌟`;
            } else if (isBackToBack) {
                if (consecutiveCount === 2) {
                    message = `🔥 Back-to-Back Champions! ${ordinal} Title! 🔥`;
                } else if (consecutiveCount === 3) {
                    message = `👑 THREE-PEAT! ${ordinal} Championship! 👑`;
                } else if (consecutiveCount >= 4) {
                    message = `🏆👑 ${consecutiveCount}-PEAT DYNASTY! ${ordinal} Championship! 👑🏆`;
                }
            } else if (nth >= 3) {
                message = `👑 Dynasty Alert: ${ordinal} Championship! 👑`;
            } else {
                message = `🎉 ${ordinal} Championship Title! 🎉`;
            }
            
            bannerEl.innerHTML = message;
            bannerEl.style.display = 'block';
        }

        function renderChampionStats(champion, scores, standings) {
            // Calculate stats from scores
            const championScores = scores.filter(s => s.team_key === champion.team_key);
            
            let wins = 0, losses = 0, totalPoints = 0, bestWeek = 0;
            championScores.forEach(matchup => {
                totalPoints += matchup.team_score || 0;
                if (matchup.team_score > matchup.opponent_score) wins++;
                else if (matchup.team_score < matchup.opponent_score) losses++;
                if (matchup.team_score > bestWeek) bestWeek = matchup.team_score;
            });

            const gamesPlayed = wins + losses;
            const ppg = gamesPlayed > 0 ? (totalPoints / gamesPlayed).toFixed(1) : '-';

            document.getElementById('champion-record').textContent = `${wins}-${losses}`;
            document.getElementById('champion-points').textContent = totalPoints.toFixed(1);
            document.getElementById('champion-ppg').textContent = ppg;
            document.getElementById('champion-best-week').textContent = bestWeek.toFixed(1);
        }

        function renderChampionSchedule(champion, scores, standings, teams) {
            const tbody = document.getElementById('champion-schedule');
            const championScores = scores.filter(s => s.team_key === champion.team_key);

            // Create team key to name and logo mapping
            const teamKeyToInfo = {};
            standings.forEach(team => {
                const teamData = teams.find(t => t.team_key === team.team_key);
                teamKeyToInfo[team.team_key] = {
                    name: team.team_name,
                    logo: teamData?.team_logo || ''
                };
            });

            // Sort by week
            championScores.sort((a, b) => a.week - b.week);

            // Determine playoff weeks (usually last 3-4 weeks)
            const maxWeek = Math.max(...championScores.map(s => s.week));
            const playoffStart = maxWeek - 2; // Assume 3 week playoffs

            const placeholderLogo = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIj48cmVjdCB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCIgZmlsbD0iI2UwZTBlMCIvPjwvc3ZnPg==';

            tbody.innerHTML = championScores.map(matchup => {
                const opponentInfo = teamKeyToInfo[matchup.opponent_key] || { name: 'Unknown', logo: '' };
                const opponentLogo = opponentInfo.logo || placeholderLogo;
                const isWin = matchup.team_score > matchup.opponent_score;
                const result = isWin ? 'W' : 'L';
                const resultClass = isWin ? 'result-win' : 'result-loss';
                const rowResultClass = isWin ? 'schedule-row-win' : 'schedule-row-loss';
                
                let rowClass = rowResultClass;
                
                // CHANGED: Wrap "Week " in a span so we can hide it with CSS on mobile
                const weekPrefix = '<span class="week-text">Week </span>';
                let weekLabel = `${weekPrefix}${matchup.week}`;
                
                if (matchup.week >= playoffStart) {
                    rowClass += ' playoff-week';
                    if (matchup.week === maxWeek) {
                        rowClass += ' championship-week';
                        weekLabel = `${weekPrefix}${matchup.week} 🏆`;
                    } else {
                        weekLabel = `${weekPrefix}${matchup.week} ⭐`;
                    }
                }

                return `
                    <tr class="${rowClass}">
                        <td>${weekLabel}</td>
                        <td>
                            <div class="schedule-opponent">
                                <img src="${opponentLogo}" alt="" class="schedule-team-logo" onerror="this.style.display='none'">
                                <span>${opponentInfo.name}</span>
                            </div>
                        </td>
                        <td>${matchup.team_score.toFixed(1)} - ${matchup.opponent_score.toFixed(1)}</td>
                        <td class="${resultClass}">${result}</td>
                    </tr>
                `;
            }).join('');
        }

        function renderChampionRoster(champion, playerStats) {
            const rosterEl = document.getElementById('champion-roster');
            
            // Filter players on champion's team
            const rosterPlayers = playerStats.filter(p => p.team_key === champion.team_key);

            if (rosterPlayers.length === 0) {
                rosterEl.innerHTML = '<p style="color: #666; text-align: center;">Roster data not available for this season.</p>';
                return;
            }

            // Separate by position type and points
            const batters = rosterPlayers.filter(p => p.position_type === 'B' && (p.fantasy_points || 0) > 0);
            const pitchers = rosterPlayers.filter(p => p.position_type === 'P' && (p.fantasy_points || 0) > 0);
            const prospects = rosterPlayers.filter(p => (p.fantasy_points || 0) === 0);

            // Sort each group by fantasy points descending
            batters.sort((a, b) => (b.fantasy_points || 0) - (a.fantasy_points || 0));
            pitchers.sort((a, b) => (b.fantasy_points || 0) - (a.fantasy_points || 0));
            prospects.sort((a, b) => (a.name || '').localeCompare(b.name || ''));

            const placeholderImg = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIj48cmVjdCB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCIgZmlsbD0iI2UwZTBlMCIvPjxjaXJjbGUgY3g9IjUwIiBjeT0iMzUiIHI9IjIwIiBmaWxsPSIjYmRiZGJkIi8+PGVsbGlwc2UgY3g9IjUwIiBjeT0iODUiIHJ4PSIzMCIgcnk9IjIwIiBmaWxsPSIjYmRiZGJkIi8+PC9zdmc+';

            const renderPlayerCard = (player, isProspect = false) => {
                const headshot = player.headshot_url || placeholderImg;
                const points = (player.fantasy_points || 0).toFixed(1);
                const cardClass = isProspect ? 'roster-player-card prospect' : 'roster-player-card';
                return `
                    <div class="${cardClass}">
                        <img src="${headshot}" alt="${player.name}" class="player-headshot" onerror="this.src='${placeholderImg}'">
                        <div class="player-info">
                            <div class="player-name">${player.name}</div>
                            <div class="player-position">${player.primary_position || '-'}</div>
                        </div>
                        <div class="player-points">
                            <div class="points-value">${points}</div>
                            <div class="points-label">pts</div>
                        </div>
                    </div>
                `;
            };

            let html = '<div class="roster-columns">';
            
            // Batters column
            html += '<div class="roster-column">';
            if (batters.length > 0) {
                html += `<div class="roster-section-title">⚾ Batters (${batters.length})</div>`;
                html += `<div class="roster-grid">${batters.map(p => renderPlayerCard(p, false)).join('')}</div>`;
            }
            html += '</div>';
            
            // Pitchers column
            html += '<div class="roster-column">';
            if (pitchers.length > 0) {
                html += `<div class="roster-section-title">🎯 Pitchers (${pitchers.length})</div>`;
                html += `<div class="roster-grid">${pitchers.map(p => renderPlayerCard(p, false)).join('')}</div>`;
            }
            html += '</div>';
            
            html += '</div>';

            // Prospects section (players with 0 points)
            if (prospects.length > 0) {
                html += '<div class="prospects-section">';
                html += `<div class="roster-section-title">🌱 Prospects (${prospects.length})</div>`;
                html += `<div class="roster-grid">${prospects.map(p => renderPlayerCard(p, true)).join('')}</div>`;
                html += '</div>';
            }

            rosterEl.innerHTML = html;
        }

        // ===== LOAD AWARDS =====
        async function loadAwards() {
            console.log("Loading awards...");
            const loadingEl = document.getElementById('awards-loading');
            const errorEl = document.getElementById('awards-error');
            const contentEl = document.getElementById('awards-content');

            try {
                loadingEl.style.display = 'block';
                errorEl.style.display = 'none';
                contentEl.style.display = 'none';

                // Load all seasons data
                const seasons = [2019, 2020, 2021, 2022, 2023, 2024, 2025];
                const seasonData = {};

                console.log("Fetching data for seasons:", seasons);

                for (const year of seasons) {
                    try {
                        let standingsResponse, teamsResponse, playerStatsResponse;

                        if (year === 2025) {
                            standingsResponse = await fetch('data/current_season/standings.json');
                            teamsResponse = await fetch('data/current_season/teams.json');
                            playerStatsResponse = await fetch('data/current_season/player_stats.json');
                        } else {
                            standingsResponse = await fetch(`data/historical/${year}/final_standings.json`);
                            teamsResponse = await fetch(`data/historical/${year}/teams.json`);
                            playerStatsResponse = await fetch(`data/historical/${year}/player_stats.json`);
                        }

                        console.log(`${year}: standings=${standingsResponse.ok}, teams=${teamsResponse.ok}, playerStats=${playerStatsResponse.ok}`);

                        if (standingsResponse.ok && teamsResponse.ok) {
                            const standings = await standingsResponse.json();
                            const teams = await teamsResponse.json();
                            const playerStats = playerStatsResponse.ok ? await playerStatsResponse.json() : [];

                            // Normalize standings
                            const normalizedStandings = normalizeStandingsData(standings, year);

                            // Create team logo map
                            const logoMap = {};
                            teams.forEach(team => {
                                logoMap[team.team_key] = team.team_logo;
                            });

                            seasonData[year] = {
                                standings: normalizedStandings,
                                logos: logoMap,
                                playerStats: playerStats
                            };
                        }
                    } catch (e) {
                        console.error(`Error loading ${year}:`, e);
                    }
                }

                console.log("Loaded season data for:", Object.keys(seasonData));

                // Calculate awards
                const regularSeasonWinners = [];
                const scoringChampions = [];
                const garbageAwards = [];
                const clownAwards = [];
                const troutAwards = [];
                const degromAwards = [];

                for (const [year, data] of Object.entries(seasonData)) {
                    const standings = data.standings;
                    const logos = data.logos;
                    const playerStats = data.playerStats || [];

                    // Regular Season Champion (most wins)
                    const mostWins = standings.reduce((max, team) =>
                        team.wins > max.wins ? team : max
                    );
                    regularSeasonWinners.push({
                        year,
                        manager: mostWins.manager,
                        team_name: mostWins.team_name,
                        logo: logos[mostWins.team_key],
                        value: mostWins.wins
                    });

                    // Scoring Champion (most points)
                    const mostPoints = standings.reduce((max, team) =>
                        team.points_for > max.points_for ? team : max
                    );
                    scoringChampions.push({
                        year,
                        manager: mostPoints.manager,
                        team_name: mostPoints.team_name,
                        logo: logos[mostPoints.team_key],
                        value: Math.round(mostPoints.points_for)
                    });

                    // Garbage Award (worst record - fewest wins)
                    const fewestWins = standings.reduce((min, team) =>
                        team.wins < min.wins ? team : min
                    );
                    garbageAwards.push({
                        year,
                        manager: fewestWins.manager,
                        team_name: fewestWins.team_name,
                        logo: logos[fewestWins.team_key],
                        wins: fewestWins.wins,
                        losses: fewestWins.losses
                    });

                    // Clown Award (least points)
                    const leastPoints = standings.reduce((min, team) =>
                        team.points_for < min.points_for ? team : min
                    );
                    clownAwards.push({
                        year,
                        manager: leastPoints.manager,
                        team_name: leastPoints.team_name,
                        logo: logos[leastPoints.team_key],
                        value: Math.round(leastPoints.points_for)
                    });

                    // Mike Trout Award (highest scoring hitter)
                    const batters = playerStats.filter(p => p.position_type === 'B');
                    if (batters.length > 0) {
                        const topHitter = batters.reduce((max, player) =>
                            (player.fantasy_points || 0) > (max.fantasy_points || 0) ? player : max
                        );
                        troutAwards.push({
                            year,
                            manager: topHitter.manager,
                            team_logo: topHitter.team_logo,
                            player_name: topHitter.name,
                            player_headshot: topHitter.headshot_url,
                            value: Math.round(topHitter.fantasy_points || 0)
                        });
                    }

                    // Jacob deGrom Award (highest scoring pitcher)
                    const pitchers = playerStats.filter(p => p.position_type === 'P');
                    if (pitchers.length > 0) {
                        const topPitcher = pitchers.reduce((max, player) =>
                            (player.fantasy_points || 0) > (max.fantasy_points || 0) ? player : max
                        );
                        degromAwards.push({
                            year,
                            manager: topPitcher.manager,
                            team_logo: topPitcher.team_logo,
                            player_name: topPitcher.name,
                            player_headshot: topPitcher.headshot_url,
                            value: Math.round(topPitcher.fantasy_points || 0)
                        });
                    }
                }

                console.log("Calculated awards:", {
                    regularSeasonWinners: regularSeasonWinners.length,
                    scoringChampions: scoringChampions.length,
                    garbageAwards: garbageAwards.length,
                    clownAwards: clownAwards.length,
                    troutAwards: troutAwards.length,
                    degromAwards: degromAwards.length
                });

                // Sort all by year (most recent first)
                [regularSeasonWinners, scoringChampions, garbageAwards, clownAwards, troutAwards, degromAwards].forEach(arr => {
                    arr.sort((a, b) => b.year - a.year);
                });

                // Populate tables
                populateAwardTable('regular-season-winners', regularSeasonWinners, (award) => `
                    <td>${award.year}</td>
                    <td><div class="manager-cell">${award.logo ? `<img src="${award.logo}" class="team-logo">` : ''}${award.manager}</div></td>
                    <td>${award.team_name}</td>
                    <td><span class="award-value">${award.value}</span></td>
                `);

                populateAwardTable('scoring-champions', scoringChampions, (award) => `
                    <td>${award.year}</td>
                    <td><div class="manager-cell">${award.logo ? `<img src="${award.logo}" class="team-logo">` : ''}${award.manager}</div></td>
                    <td>${award.team_name}</td>
                    <td><span class="award-value">${award.value.toLocaleString()}</span></td>
                `);

                populateAwardTable('garbage-awards', garbageAwards, (award) => `
                    <td>${award.year}</td>
                    <td><div class="manager-cell">${award.logo ? `<img src="${award.logo}" class="team-logo">` : ''}${award.manager}</div></td>
                    <td>${award.team_name}</td>
                    <td><span class="award-value">${award.wins}-${award.losses}</span></td>
                `);

                populateAwardTable('clown-awards', clownAwards, (award) => `
                    <td>${award.year}</td>
                    <td><div class="manager-cell">${award.logo ? `<img src="${award.logo}" class="team-logo">` : ''}${award.manager}</div></td>
                    <td>${award.team_name}</td>
                    <td><span class="award-value">${award.value.toLocaleString()}</span></td>
                `);

                // Base64 encoded placeholder for player headshots
                const placeholderImg = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIj48cmVjdCB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCIgZmlsbD0iI2UwZTBlMCIvPjxjaXJjbGUgY3g9IjUwIiBjeT0iMzUiIHI9IjIwIiBmaWxsPSIjYmRiZGJkIi8+PGVsbGlwc2UgY3g9IjUwIiBjeT0iODUiIHJ4PSIzMCIgcnk9IjIwIiBmaWxsPSIjYmRiZGJkIi8+PC9zdmc+';

                populateAwardTable('trout-awards', troutAwards, (award) => `
                    <td>${award.year}</td>
                    <td><div class="manager-cell">${award.team_logo ? `<img src="${award.team_logo}" class="team-logo">` : ''}${award.manager}</div></td>
                    <td><div class="player-award-cell"><img src="${award.player_headshot || placeholderImg}" class="player-award-headshot" onerror="this.src='${placeholderImg}'">${award.player_name}</div></td>
                    <td><span class="award-value">${award.value.toLocaleString()}</span></td>
                `);

                populateAwardTable('degrom-awards', degromAwards, (award) => `
                    <td>${award.year}</td>
                    <td><div class="manager-cell">${award.team_logo ? `<img src="${award.team_logo}" class="team-logo">` : ''}${award.manager}</div></td>
                    <td><div class="player-award-cell"><img src="${award.player_headshot || placeholderImg}" class="player-award-headshot" onerror="this.src='${placeholderImg}'">${award.player_name}</div></td>
                    <td><span class="award-value">${award.value.toLocaleString()}</span></td>
                `);

                console.log("Awards populated successfully");
                loadingEl.style.display = 'none';
                contentEl.style.display = 'block';

            } catch (error) {
                console.error('Error loading awards:', error);
                loadingEl.style.display = 'none';
                errorEl.textContent = `Error loading awards: ${error.message}`;
                errorEl.style.display = 'block';
            }
        }

        function populateAwardTable(tableId, awards, rowTemplate) {
            const tbody = document.getElementById(tableId);
            tbody.innerHTML = '';

            awards.forEach(award => {
                const row = document.createElement('tr');
                row.innerHTML = rowTemplate(award);
                tbody.appendChild(row);
            });
        }

        // ===== INITIALIZE ON PAGE LOAD =====
        window.addEventListener('DOMContentLoaded', async () => {
            // Initialize season selectors (detect available seasons)
            await initializeSeasonSelectors();

            // Load current season standings by default
            loadStandingsBySeason();

            // Load manager profiles
            loadManagerProfiles();
        });
    </script>
</body>

</html>
